{"meta":{"title":"Mogy的博客","subtitle":"","description":"","author":"Mogy","url":"https://mgy1021.github.io","root":"/"},"pages":[{"title":"所有分类","date":"2021-09-01T01:53:29.629Z","updated":"2021-09-01T01:53:29.457Z","comments":true,"path":"categories/index.html","permalink":"https://mgy1021.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-08-20T05:13:51.000Z","updated":"2021-09-01T02:20:04.645Z","comments":true,"path":"tags/index.html","permalink":"https://mgy1021.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-07T13:34:05.289Z","updated":"2021-09-07T13:34:05.189Z","comments":true,"path":"about/index.html","permalink":"https://mgy1021.github.io/about/index.html","excerpt":"","text":"下面写关于自己的内容"}],"posts":[{"title":"一个nodeJs的自动重启工具nodemon","slug":"一个nodeJs的自动重启工具nodemon","date":"2021-09-07T01:34:36.000Z","updated":"2021-09-07T14:37:24.176Z","comments":true,"path":"2021/09/07/一个nodeJs的自动重启工具nodemon/","link":"","permalink":"https://mgy1021.github.io/2021/09/07/%E4%B8%80%E4%B8%AAnodeJs%E7%9A%84%E8%87%AA%E5%8A%A8%E9%87%8D%E5%90%AF%E5%B7%A5%E5%85%B7nodemon/","excerpt":"","text":"nodemon模块node自动重启工具,监听代码文件的变化，当代码改变之后，自动启动。 全局安装1cnpm install -g nodemon 启动项目1nodemon xx.js","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"NodeJs","slug":"前端学习栈/NodeJs","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://mgy1021.github.io/tags/NodeJs/"},{"name":"nodemon","slug":"nodemon","permalink":"https://mgy1021.github.io/tags/nodemon/"}]},{"title":"nodeJs中的Mysql模块的使用","slug":"nodeJs中的Mysql模块的使用","date":"2021-09-07T01:33:54.000Z","updated":"2021-09-07T14:36:40.079Z","comments":true,"path":"2021/09/07/nodeJs中的Mysql模块的使用/","link":"","permalink":"https://mgy1021.github.io/2021/09/07/nodeJs%E4%B8%AD%E7%9A%84Mysql%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"在nodeJS中，使用mysql模块连接数据库,使用方式如下： 12345678910111213141516171819202122const mysql = require(&quot;mysql&quot;)// 1.创建连接对象let conn = mysql.createConnection(&#123; // 主机 host: &quot;8.133.167.153&quot;, // 数据库用户名 user: &quot;root&quot;, // 数据库密码 password: &quot;lq.19990312&quot;, // 连接数据库名称 database: &quot;test1&quot;&#125;);// 2.发起连接conn.connect();// 3.执行sql语句，处理结果let sql = &#x27;select * from s_student&#x27;;conn.query(sql, (error, result) =&gt; &#123; if (error) throw error; console.log(result);&#125;)// 4.关闭连接conn.end(); express+mysql搭建的简单后台12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * @Description: * @Author: Mogy * @Date: 2021-09-03 16:51:03 * @LastEditors: Mogy * @LastEditTime: 2021-09-06 15:06:28 */const express = require(&quot;express&quot;)const mysql = require(&quot;mysql&quot;)const app = express();app.get(&quot;/findAll&quot;, (req, res) =&gt; &#123; // 获取所有的学生信息，并响应 // 1.创建连接对象 let conn = mysql.createConnection(&#123; host: &quot;8.133.167.153&quot;, user: &quot;root&quot;, password: &quot;lq.19990312&quot;, database: &quot;test1&quot; &#125;) // 2.发起连接 conn.connect() // 3.执行sql语句 conn.query(&quot;select * from s_student&quot;, (error, result) =&gt; &#123; if (error) throw error; res.send(JSON.stringify(result)); conn.end() &#125;)&#125;)app.get(&quot;/deleteById&quot;, (req, res) =&gt; &#123; // 删除学生 let id = req.query.id // 1.创建连接对象 let conn = mysql.createConnection(&#123; host: &quot;8.133.167.153&quot;, user: &quot;root&quot;, password: &quot;lq.19990312&quot;, database: &quot;test1&quot; &#125;) // 2.发起连接 conn.connect() // 3.执行sql语句 conn.query(`delete from s_student where id=$&#123;id&#125;`, (error, result) =&gt; &#123; if (error) throw error; console.log(result); res.send(&quot;删除成功&quot;); conn.end() &#125;)&#125;)app.listen(3000, () =&gt; &#123; console.log(&quot;3000端口已启动&quot;);&#125;) 使用连接池Pooling connections连接数据库为了避免每一次与数据库交互都要创建连接对象，我们可以把连接对象放到连接池中进行管理。当需要与数据库进行交互时，调用连接池中的连接对象进行交互即可，无需再重新创建连接对象。注意：连接池中的连接对象是可限定数量的。 一、连接池的使用1. 创建连接对象12345678// 创建连接池对象var pool = mysql.createPool(&#123; connectionLimit:10, host:&quot;example.org&quot;, user:&quot;bob&quot;, password:&quot;secert&quot;, database:&quot;my_db&quot;&#125;) 2. 使用连接池与数据库交互12345678910111213141516171819const mysql = require(&quot;mysql&quot;)// 1.创建连接池对象let pool = mysql.createPool(&#123; // 在连接池里最多有10个连接对象 connectionLimit: 10, host:&quot;example.org&quot;, user:&quot;bob&quot;, password:&quot;secert&quot;, database:&quot;my_db&quot;&#125;)// 2.使用连接池对象执行sql语句，处理结果pool.query(&quot;select * from s_student&quot;, (error, result) =&gt; &#123; if (error) throw error; console.log(result); // 3.关闭连接池 pool.end()&#125;) 二、连接池与连接对象结合使用1234567891011121314151617181920212223const mysql = require(&quot;mysql&quot;)// 1.创建连接池对象let pool = mysql.createPool(&#123; connectionLimit: 10, host: &quot;8.133.167.153&quot;, user: &quot;root&quot;, password: &quot;lq.19990312&quot;, database: &quot;test1&quot;&#125;)// 2.获取连接对象pool.getConnection((err, conn) =&gt; &#123; // 如果不出错，conn就是连接对象 if (err) throw err; // 3.使用连接对象执行sql语句，并处理结果 conn.query(&quot;select * from s_student&quot;, (error, result) =&gt; &#123; if (error) throw error; console.log(result); // 4.释放连接对象 conn.release(); // 5.关闭连接池(一般不需要关闭连接池) // pool.end() &#125;)&#125;) sql注入在不使用sql注入之前，查询某一个人的信息需要拼接一个变量 1let sql = `select * from s_student where id=$&#123;id&#125;` 使用sql注入：query方法的第二个参数是一个数据，用来接收sql注入的数据。sql注入依赖问号，数组内元素的顺序与sql中问号的顺序一一对应 使用sql注入查询某一记录123456789101112131415// 2.获取连接对象pool.getConnection((err, conn) =&gt; &#123; // 如果不出错，conn就是连接对象 if (err) throw err; let sql = &quot;select * from s_student where id=?&quot; // 3.使用连接对象执行sql语句，并处理结果 conn.query(sql, [1], (error, result) =&gt; &#123; if (error) throw error; console.log(result); // 4.释放连接对象 conn.release(); // 5.关闭连接池(一般不需要关闭连接池) // pool.end() &#125;)&#125;) 使用sql注入插入一条记录123456789101112131415// 2.获取连接对象pool.getConnection((err, conn) =&gt; &#123; // 如果不出错，conn就是连接对象 if (err) throw err; let sql = &quot;insert into s_student(id,name,gender,birth) values(?,?,?,?) &quot; // 3.使用连接对象执行sql语句，并处理结果 conn.query(sql, [null, &quot;lisi&quot;, &quot;男&quot;, &quot;2020-5-08&quot;], (error, result) =&gt; &#123; if (error) throw error; console.log(result); // 4.释放连接对象 conn.release(); // 5.关闭连接池(一般不需要关闭连接池) // pool.end() &#125;)&#125;) 使用sql注入更新一条记录1234567891011121314pool.getConnection((err, conn) =&gt; &#123; // 如果不出错，conn就是连接对象 if (err) throw err; let sql = &quot;update s_student set name=?,gender=? where id=?&quot; // 3.使用连接对象执行sql语句，并处理结果 conn.query(sql, [&quot;lisa&quot;, &quot;女&quot;, 7], (error, result) =&gt; &#123; if (error) throw error; console.log(result); // 4.释放连接对象 conn.release(); // 5.关闭连接池(一般不需要关闭连接池) pool.end() &#125;)&#125;) 使用sql注入删除一条记录123456789101112131415// 2.获取连接对象pool.getConnection((err, conn) =&gt; &#123; // 如果不出错，conn就是连接对象 if (err) throw err; let sql = &quot;delete from s_student where id=?&quot; // 3.使用连接对象执行sql语句，并处理结果 conn.query(sql, [6], (error, result) =&gt; &#123; if (error) throw error; console.log(result); // 4.释放连接对象 conn.release(); // 5.关闭连接池(一般不需要关闭连接池) pool.end() &#125;)&#125;) 批量删除不能用sql注入，只能用字符串拼接12345678910111213141516// 2.获取连接对象pool.getConnection((err, conn) =&gt; &#123; // 如果不出错，conn就是连接对象 if (err) throw err; let str = &quot;9,10,11&quot; let sql = `delete from s_student where id in ($&#123;str&#125;)` // 3.使用连接对象执行sql语句，并处理结果 conn.query(sql, (error, result) =&gt; &#123; if (error) throw error; console.log(result); // 4.释放连接对象 conn.release(); // 5.关闭连接池(一般不需要关闭连接池) pool.end() &#125;)&#125;) 总结使用mysql模块的方式： 可以单纯使用连接对象执行sql 也可以单纯使用连接池对象执行sql 还可以使用连接池+连接对象执行sql","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"NodeJs","slug":"前端学习栈/NodeJs","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://mgy1021.github.io/tags/NodeJs/"},{"name":"Mysql","slug":"Mysql","permalink":"https://mgy1021.github.io/tags/Mysql/"}]},{"title":"一个基于nodeJs的express服务器框架","slug":"一个基于nodeJs的express服务器框架","date":"2021-09-07T01:33:13.000Z","updated":"2021-09-07T14:33:55.206Z","comments":true,"path":"2021/09/07/一个基于nodeJs的express服务器框架/","link":"","permalink":"https://mgy1021.github.io/2021/09/07/%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8EnodeJs%E7%9A%84express%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/","excerpt":"","text":"Express应用程序生成器Express是一个基于Node.js平台、快速、开放、极简的Web开发框架 通过该应用的生成器工具express-generator可以快速创建一个应用的框架。类似前端的脚手架。 安装1.全局安装1npm install -g express-generator 使用1.创建项目1234567891011121314// 引入express模块const express = require(&quot;express&quot;)// 创建express项目const express = express()// 端口号port = 3000app.get(&quot;/&quot;,(req,res)=&gt;&#123; res.send(&quot;Hello World!&quot;)&#125;)// 监听端口，启动express服务器app.listen(port,()=&gt;&#123; console.log(`Example app listening at http://localhost:$&#123;port&#125;`)&#125;)","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"NodeJs","slug":"前端学习栈/NodeJs","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://mgy1021.github.io/tags/NodeJs/"}]},{"title":"nodeJ中的Buffer缓冲器","slug":"nodeJ中的Buffer缓冲器","date":"2021-09-07T01:32:01.000Z","updated":"2021-09-07T14:34:25.379Z","comments":true,"path":"2021/09/07/nodeJ中的Buffer缓冲器/","link":"","permalink":"https://mgy1021.github.io/2021/09/07/nodeJ%E4%B8%AD%E7%9A%84Buffer%E7%BC%93%E5%86%B2%E5%99%A8/","excerpt":"","text":"Buffer缓冲器Buffer类被引入作为Node.js API的一部分，使其可以在TCP流或文件系统操作等场景中处理二进制数据流。可以将Buffer理解为输送二进制数据流的缓存。 Buffer类在全局作用域中，无需导入","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"NodeJs","slug":"前端学习栈/NodeJs","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://mgy1021.github.io/tags/NodeJs/"}]},{"title":"nodeJ中的s文件系统","slug":"nodeJ中的s文件系统","date":"2021-09-07T01:31:39.000Z","updated":"2021-09-07T14:34:18.799Z","comments":true,"path":"2021/09/07/nodeJ中的s文件系统/","link":"","permalink":"https://mgy1021.github.io/2021/09/07/nodeJ%E4%B8%AD%E7%9A%84s%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"使用Node.js读取文件在Nodejs中读取文件最简单的方法是使用fs.readFile()方法，参数：文件路径，字符编码，回调函数。 12345678// 读取文件fs.readFile(&#x27;./1-url.js&#x27;, &#x27;utf8&#x27;, (err, data) =&gt; &#123; if (err) &#123; console.log(err); return &#125; console.log(data);&#125;) 同步版本fs.readFileSync() 使用Node.js写入文件写入文件最简单的方法是使用fs.writeFile()方法,参数：(写入文件，写入内容，回调函数) 12345678// 写入文件fs.writeFile(&quot;./hello.txt&quot;, &quot;hello123&quot;, err =&gt; &#123; if (err) &#123; console.log(err); return &#125; console.log(&quot;写入成功!&quot;);&#125;) 同步版本fs.writeFileSync() 同步读写文件1234567// 同步读写操作try &#123; let data = fs.readFileSync(&quot;./1-url.js&quot;, &quot;utf8&quot;); fs.writeFileSync(&quot;./1-url2.js&quot;, data)&#125; catch (error) &#123; console.log(error);&#125;","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"NodeJs","slug":"前端学习栈/NodeJs","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://mgy1021.github.io/tags/NodeJs/"}]},{"title":"nodeJs中的进程","slug":"nodeJs中的进程","date":"2021-09-07T01:31:22.000Z","updated":"2021-09-07T14:37:03.072Z","comments":true,"path":"2021/09/07/nodeJs中的进程/","link":"","permalink":"https://mgy1021.github.io/2021/09/07/nodeJs%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B/","excerpt":"","text":"process(进程)process对象是一个全局变量，提供了有关当前Node.js进程的信息并对其进行控制。作为全局变量，它始终可供Node.js应用程序使用，无需使用require()导入。 12345678910process.env.NODE_ENV = &quot;development&quot;process.env.BaseURL = &quot;127.0.0.1:8888&quot;console.log(process.env.NODE_ENV);// console.log(process);// 环境对象console.log(process.env);// 参数数组console.log(process.argv);// 关闭进程的方法// process.exit(1); 处理命令行参数： 123const minimist = require(&quot;minimist&quot;);// 处理命令行的参数console.log(minimist(process.argv.slice(2)));","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"NodeJs","slug":"前端学习栈/NodeJs","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://mgy1021.github.io/tags/NodeJs/"},{"name":"进程","slug":"进程","permalink":"https://mgy1021.github.io/tags/%E8%BF%9B%E7%A8%8B/"}]},{"title":"nodeJs搭建简单Http服务器","slug":"nodeJs搭建简单Http服务器","date":"2021-09-07T01:30:54.000Z","updated":"2021-09-07T14:36:20.602Z","comments":true,"path":"2021/09/07/nodeJs搭建简单Http服务器/","link":"","permalink":"https://mgy1021.github.io/2021/09/07/nodeJs%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95Http%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"Http服务器这是一个简单的HTTP web服务器 1.创建服务器对象​ 浏览器每发一次请求，都会运行该函数。 req是请求对象，通过它可以拿到请求的方式、路径、参数,res是响应对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 创建服务器对象let server = http.createServer((req, res) =&gt; &#123; // 设置响应头部的字符编码 res.setHeader(&quot;Content-Type&quot;, &quot;text/plain;charset=utf-8&quot;) // 浏览器每发一次请求，都会运行该函数 // 获取请求方式，获取请求路径，获取请求参数 console.log(req.method); console.log(req.url); // 获取请求路径 let pathname = url.parse(req.url).pathname // 获取get请求参数 // let query = url.parse(req.url).query // 获取post请求的参数 // let params = &quot;&quot;; // 请求发送请求体里的数据的时候触发data事件处理程序 // req.on(&quot;data&quot;, (chunk) =&gt; &#123; // // chunk是Buffer对象,存放一段一段的数据 // params += chunk // &#125;) // end事件监听请求数据发送完毕 // req.on(&quot;end&quot;, () =&gt; &#123; // console.log(params); // &#125;) // console.log(pathname); // console.log(query); // 不同接口路径返回不同数据 if (pathname === &quot;/user/findAll&quot;) &#123; res.end(&#x27;user的findAll&#x27;); &#125; else if (pathname === &quot;/user/deleteById&quot;) &#123; res.end(&#x27;user的deleteById&#x27;); &#125; // 编写响应体的内容 // res.write(&quot;123&quot;); // 结束响应 // res.end();&#125;) 2.启动服务器1234// 启动服务器server.listen(3000, () =&gt; &#123; console.log(&quot;3000端口启动&quot;);&#125;)","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"NodeJs","slug":"前端学习栈/NodeJs","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://mgy1021.github.io/tags/NodeJs/"},{"name":"Http服务器","slug":"Http服务器","permalink":"https://mgy1021.github.io/tags/Http%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"git","slug":"git","date":"2021-08-30T16:34:30.000Z","updated":"2021-09-06T16:15:09.914Z","comments":true,"path":"2021/08/31/git/","link":"","permalink":"https://mgy1021.github.io/2021/08/31/git/","excerpt":"","text":"初始化本地仓库 git init 更新代码 git pull origin master 提交代码 git add . 将需要提交的所有文件添加到缓存区 git commit -m &#39;提交注释&#39; 将缓存区的内容提交到本地仓库里 git remote add origin 仓库地址 将本地仓库与远程仓库绑定 git push origin master 将本地仓库需要提交的文件推送到远程仓库 解绑仓库 git remote remove 仓库名称 查看与本地仓库绑定的远程仓库 git remote -v","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"git","slug":"前端学习栈/git","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://mgy1021.github.io/tags/Git/"}]},{"title":"ES6","slug":"ES6","date":"2021-08-30T16:33:11.000Z","updated":"2021-09-07T14:26:40.429Z","comments":true,"path":"2021/08/31/ES6/","link":"","permalink":"https://mgy1021.github.io/2021/08/31/ES6/","excerpt":"","text":"1. 为什么要学习ES6 ES的本版变动内容最多，具有里程碑意义 ES6加入许多新的语法特性，编程实现更简单、高效 ES6是前端发展趋势，就业必备技能（在三大框架中大量使用了ES6的语法） 2. ES6的新语法1. let声明变量 变量不能重复声明 块级作用域(变量只在代码块里面有效) 不存在变量提升 不影响作用域链 2. const声明常量 常量的值不能修改 声明时必须赋值 块级作用域 对于数组或者对象进行修改，不会报错 3. 结构赋值 ES6允许按照一定模型从数组或者对象中提取值，对变量进行赋值，这被称为解构赋值。 数组解构 1234567const F4 = [&quot;小沈阳&quot;,&quot;刘能&quot;,&quot;赵四&quot;,&quot;宋小宝&quot;]let [xiao,liu,zhao,song] = F4console.log(xiao); // 小沈阳console.log(liu); // 刘能console.log(xiao); // 赵四console.log(song); // 宋小宝 对象解构 12345678910111213const zhao = &#123; name:&#x27;赵本山&#x27;, age:&quot;不详&quot;, xiaopin:function()&#123; console.log(&quot;我可以演小品&quot;); &#125;&#125;let &#123;name.age,xiaopin&#125; = zhao;console.log(name);console.log(age);console.log(xiaopin); 4. 模板字符串 ES6引入新的声明字符串的方式 1let str = `我是一个模板字符串哦` 特性： 内容中可以直接出现换行符 变量拼接 let lovest = &#39;魏翔&#39; 1let out = `$&#123;lovest&#125;是我心目中最搞笑的演员` 5. 简化对象 ES6允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。 123456789101112let name = &quot;Mogy&quot;;let change = function()&#123; console.log(&quot;我们可以改变你&quot;)&#125;const school = &#123; name, change, improve()&#123; console.log(&quot;我们可以提升你的技能&quot;) &#125;&#125; 6.箭头函数 特性 this是静态的，this始终是指向函数声明时所在作用域下的this的值。 不能作为构造实例化对象 不能使用arguments变量 箭头函数的简写 省略小括号，当形参有且只有一个时可省略 省略大括号，当代码体中的语句只有一句时可以省略 let pow = n =&gt; n*n 使用场景 箭头函数适合与this无关的回调，定时器，数组的方法回调 箭头函数不适合与this有关的回调，事件回调，对象的方法 7. ES6允许给函数参数赋值初始值 形参初始值（具有默认值的参数，一般位置要靠后） 12345function add(a,b,c=10)&#123; return a+b+c&#125;let result = add(1,2,3) // 6let result = add(1,2) // 13 与解构赋值结合使用 12345678910111213function connect(&#123;host = 127.0.0.1,username,password,port&#125;)&#123; console.log(host); console.log(username); console.log(password); console.log(port);&#125;connect(&#123; host:&#x27;baidu.com&#x27;, username:&#x27;root&#x27;, password:&#x27;root&#x27;, port:3306&#125;) 8. rest参数 ES6引入reset参数，用于获取函数的实参，用来代替arguments 12345function date(...args)&#123; console.log(args);&#125;date(&#x27;阿娇&#x27;,&#x27;柏芝&#x27;,&#x27;思慧&#x27;); //数组 可以使用filter some every map等数组方法 reset参数必须要放到参数最后 9. 扩展运算符... 扩展运算符能将数组转换为逗号分隔的参数列表。 1const tfboys = [&quot;易烊千玺&quot;,&quot;王源&quot;,&quot;王俊凯&quot;];//声明一个函数function chunwan()&#123; console.log(arguments)&#125;chunwan(...tfboys) // chunwan(&quot;易烊千玺&quot;,&quot;王源&quot;,&quot;王俊凯&quot;)// 数组的克隆const sanzhihua = [&#x27;E&#x27;,&#x27;G&#x27;,&#x27;M&#x27;];const sanyecao = [...sanzhihua] // [&#x27;E&#x27;,&#x27;G&#x27;,&#x27;M&#x27;] 10. Symbol基本使用 ES6引入了一种新的数据类型Symbol，表示独一无二的值。它是JS语言的第七种数据类型，是一种类似于字符串的数据类型。 Symbol的特点 Symbol的值是唯一的，用来解决命名冲突的问题 Symbol的值不能与其他数据进行运算 Symbol定义的对象属性不能使用for...in循环遍历，但是可以使用Reflect.ownKeys来获取对象的所有键名 1//创建一个Symbollet s = Symbol();console.log(s,typeof s); // Symbol() &quot;Symbol&quot;let s2 = Symbol(&quot;注释&quot;);let s3 = Symbol(&quot;注释&quot;);console.log(s2 == s3) // false// Symbol.for 创建let s4 = Symbol.for(&#x27;Mogy&#x27;);let s5 = Symbol.for(&#x27;Mogy&#x27;);console.log(s4 == s5) // true Symbol的使用场景 给对象添加属性或者方法，表示独一无二的 1let game = &#123; name: &#x27;俄罗斯方块&#x27;, up() &#123; console.log(&quot;向上&quot;); &#125;, down() &#123; console.log(&quot;向下&quot;); &#125; &#125; let methods = &#123; up: Symbol(), down: Symbol(), &#125; game[methods.up] = function () &#123; console.log(&quot;我可以改变形状&quot;); &#125; game[methods.down] = function () &#123; console.log(&quot;我可以快速下降&quot;); &#125; console.log(game); 11. 迭代器​ 迭代器是一种接口，为各种不同的数据类型提供统一的访问机制。任何数据结构只要部署了Iterator接口(指的是对象里的一个属性)，就可以完成遍历操作。 原生具备Iterator接口的数据 Array Arguments Set Map String TypedArray NodeList 工作原理 创建一个指针对象，指向当前数据结构的起始位置 第一次调用对象的next方法，指针自动指向数据结构的第一个成员 接下来不断调用next方法，指针一直往后移动，直到指向最后一个成员 12. 生成器​ 生成器其实就是一个特殊的函数 1function* gen()&#123; console.log(111); yield one() console.log(222); yield two(); console.log(333); yield three();&#125;let Iterator = gen() // 返回一个迭代器对象Iterator.next() // 111 13. Set集合​ ES6提供了新的数据结构Set集合，它是一个对象，类似于数组，但是成员是唯一的。 1//声明一个 setlet s = new Set();let s2 = new Set([&quot;好事&quot;,&quot;喜事&quot;,&quot;坏事&quot;,&quot;丑事&quot;,&quot;好事&quot;]);console.log(typeof s) // Object// 获取元素的个数console.log(s2.size) // 4// 添加元素s2.add(&quot;悲事&quot;)// 删除元素s2.delete(&quot;好事&quot;)// 检测s2.has(&quot;好事&quot;)// 清空s2.clear() 14.类15.数值扩展 Number.EPSILON Number.EPSILON是JavaScript表示的最小精度 1console.log(0.1+0.2 === 0.3) // falsefunction equal(a,b)&#123; if(Math.abs(a-b) &lt; Number.EPSILON)&#123; return true; &#125;else&#123; return false; &#125;&#125;console.log(equal(0.1+0.2,0.3)) // true Number.isFinite 检查一个数值是否为有限数 Number.isNaN 检测一个数值是否为NaN Number.parseInt 字符串转整数 Number.isInteger 判断一个数是否为整数 Math.trunc 将数字的小数部分抹掉 Math.sign 判断一个数是整数、负数还是零 16.对象方法的扩展 Object.is 判断两个值是否完全相等 Object.assign 对象合并 Object.setPrototypeOf Object.getPrototypeOf 设置原型对象 17.模块化​ 模块化是指将一个大的程序文件，拆分成许多小的文件，然后将小文件组合起来。 模块化开发的好处 防止命名冲突 代码复用 高维护性 模块化规范 CommonJS =&gt; NodeJS、Browserify AMD =&gt; requireJS CMD =&gt; seaJS ES6模块化语法 export命令用于规定模块的对外接口 import命令用于输入其他模块提供的功能 导出的方式： export let a = 2 export &#123;a,method&#125; export default &#123;对象&#125; 引入的方式： 通用方式 import * as m1 from &quot;...&quot; 解构赋值形式 import &#123;school,teach&#125; from &quot;...&quot; import &#123;default as m3&#125; from &quot;...&quot; 简便形式(针对默认暴露) import m3 from &quot;...&quot; babel 1npx babel 文件 -d 文件夹 --presets=babel-preset-env 模块化的差异 ES6模块与CommonJS模块化的差异： CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用 ES6模块加载的不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。 ES6模块输出的是值的引用 CommonJS模块是运行时加载，ES6模块时编译时输出接口 加载的是一个对象,即module.exports属性，该对象只有在脚本运行完才能完成。 3. ES7的新特性 Array.prototype.includes 用来检测数组中是否包含某个元素，返回布尔类型值 **幂运算 相当于Math.pow(), 2**3 ==&gt; Math.pow(2,3) 4.ES8的新特性4.1 async和await​ 异步编程的解决方案，async和await两种语法结合可以让异步代码像同步代码一样编写 4.1.1 async函数 async函数的返回值为promise对象 promise对象的结果由async函数执行的返回值决定 4.1.2 await表达式 await必须写在async函数中 await右侧的表达式一般为promise对象 await返回的是promise成功的值 await的promise失败了，就会抛出异常，需要通过try…catch捕获处理","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"ES6","slug":"前端学习栈/ES6","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://mgy1021.github.io/tags/ES6/"}],"author":"Mogy"},{"title":"Ajax","slug":"Ajax","date":"2021-08-30T16:30:29.000Z","updated":"2021-09-07T13:12:58.498Z","comments":true,"path":"2021/08/31/Ajax/","link":"","permalink":"https://mgy1021.github.io/2021/08/31/Ajax/","excerpt":"","text":"AJAX的特点1.AJAX的优点 （1）可以无需刷新页面与服务器进行通信 （2）允许你根据用户事件来更新部分网页内容 2.AJAX的缺点 （1）没有浏览历史，不能回退 （2）存在跨域问题（同源） （3）SEO不友好 AJAX的使用1.AJAX的基本操作 12345678910111213141516&lt;!-- 1.创建对象 --&gt;const xhr = new XMLHttpRequest()&lt;!-- 2.初始化 设置请求方式和URL --&gt;xhr.open(&#x27;GET&#x27;，URL)&lt;!-- 3.发送 --&gt;xhr.send()&lt;!-- 4.绑定事件 --&gt;xhr.onreadyStateChange = function () &#123; &lt;!-- 判断（服务器是否返回全部结果） --&gt; if(xhr.readyState === 4)&#123; &lt;!-- 判断（响应是否成功） --&gt; if(xhr.status &gt;= 200&amp;&amp;xhr.status &lt; 300)&#123; console.log(xhr.response) &#125; &#125;&#125; 2.传参 （1）GET请求 在URL后面拼接，例如:http://127.0.0.1:8000/server?username=Mogy&amp;age=12 （2）POST请求 在send方法中传参，例如：xhr.send(‘username=Mogy&amp;age=12’) 3.超时请求和网络异常处理 （1）超时请求 xhr.timeout = 2000 （2）网络异常处理 123xhr.onerror = function () &#123; alert(&quot;你的网络似乎出了问题!!!&quot;) &#125; 4.手动取消请求 （1）xhr.abort() Jquery发送ajax1.发GET $.get(url,data,function()&#123;&#125;,&#39;json&#39;) 2.发POST $.post(url,data,function()&#123;&#125;) 3.通用方法 12345678910111213141516$.ajax(&#123; &lt;!-- 请求路径 --&gt; url:&#x27;&#x27;, &lt;!-- 请求方式 --&gt; type:&#x27;&#x27;, &lt;!-- 参数 --&gt; data:&#123;&#125;, &lt;!-- 设置响应体的数据类型 --&gt; datatype:&#x27;json&#x27; &lt;!-- 成功回调 --&gt; success()&#123;&#125;, &lt;!-- 错误回调 --&gt; error()&#123;&#125;, &lt;!-- 设置请求超时 --&gt; timeout:2000,&#125;) axios发ajax1.发GET请求 axios.get(url,config).then().catch() 2.发POST请求 axios.post(url,data,config),then().catch() 3.通用方法 123456789101112axios(&#123; &lt;!-- 请求路径 --&gt; url:&#x27;&#x27;, &lt;!-- 请求方式 --&gt; method:&#x27;&#x27;, &lt;!-- 设置请求头 --&gt; headers:&#123;&#125;, &lt;!-- 请求体 --&gt; data:&#123;&#125; &lt;!-- url传参 --&gt; params:&#123;&#125;&#125;) ajax同源策略 1.同源策略是浏览器的一种安全策略 2.同源：协议、域名、端口号 必须完全相同 3.违背同源策略就是跨域 解决跨域： Jsonp Cros 浏览器解决跨域： https://blog.csdn.net/qq_37338983/article/details/78606064 火狐浏览器下载CORS-EVERYWHERE插件即可解决跨域问题 HTTP协议1.HTTP简介 超文本传输协议，协议详细规定了浏览器和万维网服务器之间相互通信的规则 2.内容 1.请求报文 重点是格式和参数： 1234行 POST /s?ie=utf-8 HTTP/1.1头 空行体 2.响应报文 1234行 HTTP/1.1 200 OK头空行体","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"Ajax","slug":"前端学习栈/Ajax","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/Ajax/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://mgy1021.github.io/tags/Ajax/"}]},{"title":"Webpack","slug":"Webpack","date":"2021-08-20T01:31:05.000Z","updated":"2021-09-08T01:11:06.916Z","comments":true,"path":"2021/08/20/Webpack/","link":"","permalink":"https://mgy1021.github.io/2021/08/20/Webpack/","excerpt":"","text":"Webpack的简介1. 什么是Webpack？Webpac是一种前端资源构建工具，一个静态模块打包器(module bundler)。 在Webpack看来，前端的所有资源文件(js/json/css/img/less/…)都会作为模块处理。它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源(bundle)。 2. Webpack的五个核心概念2.1 Entry​ 入口(entry)指示Webpack以哪个文件为入口起点开始打包，分析构建内部依赖图。 2.2 Output​ 输出(output)指示Webpack打包后的资源bundle输出到哪里去，以及如何命名。 2.3 loader​ Loader让webpack能够处理一些非JavaScript文件(webpack自身只认识JavaScript) 2.4 Plugins​ 插件(Plugins)可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩一直到重新定义环境中的变量等。 2.5 Mode​ 模式(Mode)指示Webpack使用相应模式的配置。 选项 描述 特点 development 会将process.env.NODE_ENV的值设为development。启用NamedChunksPlugin和NamedModulesPlugin. 能够让本地调试运行环境 production 会将process.env.NODE_ENV的值设为production。启用FlagDependencyUsagePlugin等 能够让代码优化上线运行的环境 3. Webpack初体验3.1 运行指令​ 开发环境：webpack ./src/index.js -o ./build/build.js –mode=development ​ webpack会以 ./src/index.js为入口文件开始打包，打包后输出到./build/built.js文件 ​ 整体打包环境是开发环境 ​ 生产环境：webpack ./src/index.js -o ./build/build.js –mode=production ​ webpack会以 ./src/index.js为入口文件开始打包，打包后输出到./build/built.js文件 ​ 整体打包环境是生产环境 3.2 结论 webpack能处理js/json资源,不能处理css/img等其他资源。 生产环境和开发环境将ES6模块化编译成浏览器能识别的模块化。 生产环境比开发环境多一个压缩代码。 4. 打包样式资源webpack.config.js是webpack的配置文件 作用：指示webpack干哪些活（当你运行webpack指令时，会加载里面的配置） 注意：所有构建工具都是基于nodejs平台运行的~模块化默认采用commonJS 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* * @Description: * @Author: Mogy * @Date: 2021-08-19 14:51:29 * @LastEditors: Mogy * @LastEditTime: 2021-08-19 15:34:37 *///resolve用来拼接绝对路径的方法const &#123; resolve &#125; = require(&quot;path&quot;)module.exports = &#123; // webpack配置 entry: &#x27;./src/index.js&#x27;, // 输出 output: &#123; // 输出文件名 filename: &#x27;built.js&#x27;, // 输出的路径 //__dirname nodejs的变量，代表当前文件所在目录的绝对路径 path: resolve(__dirname, &#x27;build&#x27;) &#125;, //loader的配置 module: &#123; rules: [ //详细的loader配置 // 不同文件必须配置不同的loader处理 &#123; //匹配哪些文件 test: /\\.css$/, // 使用哪些loader进行处理 use: [ //use数组中loader执行顺序：从右到左，从上到下。依次执行 //创建style标签，将js中的css样式资源插入进去，添加到head中生效 &#x27;style-loader&#x27;, //将css文件编成commonJS模块加载到js中，里面的内容是样式字符串 &#x27;css-loader&#x27; ] &#125;, &#123; test: /\\.less$/, use: [ &quot;style-loader&quot;, &quot;css-loader&quot;, // 将less文件编译成css文件 &quot;less-loader&quot; ] &#125; ] &#125;, // plugins的配置 plugins: [ //详细plugins的配置 ], // 模式 mode: &#x27;development&#x27;, // mode: &#x27;production&#x27;&#125; 5. Webpack打包html资源123456789101112131415161718192021222324252627282930313233343536373839404142434445/* * @Description: * @Author: Mogy * @Date: 2021-08-19 15:45:13 * @LastEditors: Mogy * @LastEditTime: 2021-08-19 16:00:22 *//* loader: 1. 下载 2. 使用（配置loader） plugins： 1. 下载 2. 引入 3. 使用*/const &#123; resolve &#125; = require(&#x27;path&#x27;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;built.js&#x27;, path: resolve(__dirname, &quot;build&quot;) &#125;, module: &#123; rules: [ // loader的配置 ] &#125;, plugins: [ // plugins的配置 // html-webpack-plugin // 功能：默认会创建一个空的HTML文件，自动引入打包输出的所有资源(JS/CSS) // 需求：需要有结构的HTML文件 new HtmlWebpackPlugin(&#123; // 复制一个HTML文件，并自动引入打包输出的所有资源(JS/CSS) template: &#x27;./src/index.html&#x27; &#125;) ], mode: &quot;development&quot;&#125; 6. Webpack打包图片资源","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"Webpack","slug":"前端学习栈/Webpack","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://mgy1021.github.io/tags/Webpack/"}]}],"categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"NodeJs","slug":"前端学习栈/NodeJs","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/NodeJs/"},{"name":"git","slug":"前端学习栈/git","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/git/"},{"name":"ES6","slug":"前端学习栈/ES6","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/ES6/"},{"name":"Ajax","slug":"前端学习栈/Ajax","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/Ajax/"},{"name":"Webpack","slug":"前端学习栈/Webpack","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/Webpack/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://mgy1021.github.io/tags/NodeJs/"},{"name":"nodemon","slug":"nodemon","permalink":"https://mgy1021.github.io/tags/nodemon/"},{"name":"Mysql","slug":"Mysql","permalink":"https://mgy1021.github.io/tags/Mysql/"},{"name":"进程","slug":"进程","permalink":"https://mgy1021.github.io/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"Http服务器","slug":"Http服务器","permalink":"https://mgy1021.github.io/tags/Http%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Git","slug":"Git","permalink":"https://mgy1021.github.io/tags/Git/"},{"name":"ES6","slug":"ES6","permalink":"https://mgy1021.github.io/tags/ES6/"},{"name":"Ajax","slug":"Ajax","permalink":"https://mgy1021.github.io/tags/Ajax/"},{"name":"Webpack","slug":"Webpack","permalink":"https://mgy1021.github.io/tags/Webpack/"}]}