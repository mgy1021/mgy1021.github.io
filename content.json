{"meta":{"title":"Mogy的博客","subtitle":"","description":"","author":"Mogy","url":"https://mgy1021.github.io","root":"/"},"pages":[{"title":"所有分类","date":"2021-09-01T01:53:29.629Z","updated":"2021-09-01T01:53:29.457Z","comments":true,"path":"categories/index.html","permalink":"https://mgy1021.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-08-20T05:13:51.000Z","updated":"2021-09-01T02:20:04.645Z","comments":true,"path":"tags/index.html","permalink":"https://mgy1021.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-07T13:34:05.289Z","updated":"2021-09-07T13:34:05.189Z","comments":true,"path":"about/index.html","permalink":"https://mgy1021.github.io/about/index.html","excerpt":"","text":"下面写关于自己的内容"}],"posts":[{"title":"BFC","slug":"BFC","date":"2021-10-28T07:02:47.000Z","updated":"2021-10-28T07:03:35.393Z","comments":true,"path":"2021/10/28/BFC/","link":"","permalink":"https://mgy1021.github.io/2021/10/28/BFC/","excerpt":"","text":"BFC的定义12BFC(Block formatting context)直译伪”块级格式化上下文“。它是一个独立的渲染区域，只有Block-level box参与，它规定了内部的Block-level box如何布局，并且与这个区域外部毫不相干。开启BFC该元素会变成一个独立的布局区域 元素开启BFC的特点： 开启BFC的元素不会被浮动元素所覆盖 开启BFC的元素子元素和父元素的外边距不会重叠 开启BFC的元素可以包含浮动的子元素 如何开启BFC： 设置元素的浮动（不推荐） 将元素设置为行内块元素（不推荐） 将元素的overflow设置为一个非visible的值 常用的方式：为元素设置overflow:hidden 开启BFC使其可以包含浮动元素。 高度塌陷问题 ​ 在浮动的布局中，父元素的高度默认是被子元素撑开的，当子元素浮动后，其会完全脱离文档流，子元素从文档流中脱离，导致父元素的高度丢失。 ​ 父元素高度丢失后，其下的元素会自动上移，导致页面的布局混乱 所以高度塌陷是浮动布局中比较常见的问题，这个问题我们必须要进行处理。 解决方案 开启BFC 在末尾添加一个伪元素 12345::after&#123; content:&#x27;&#x27;; display:block; clear:both&#125; 外边距重叠解决方案 1234::before&#123; content:&#x27;&#x27;; display:table;&#125; 最终本版 ​ 同时解决高度塌陷和外边距重叠问题 123456.clearfix::before,.clearfix::after&#123; content:&#x27;&#x27;; display:table; clear:both;&#125;","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"CSS","slug":"前端学习栈/CSS","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://mgy1021.github.io/tags/CSS/"}]},{"title":"Web存储","slug":"Web存储","date":"2021-10-28T07:00:27.000Z","updated":"2021-10-28T07:01:07.072Z","comments":true,"path":"2021/10/28/Web存储/","link":"","permalink":"https://mgy1021.github.io/2021/10/28/Web%E5%AD%98%E5%82%A8/","excerpt":"","text":"HTML5 Web 存储HTML5 Web 存储,一个比cookie更好的本地存储方式。 什么是HTML5 Web 存储？使用HTML5可以在本地存储用户的浏览数据。在早期本地存储使用的是cookie。cookie的存储大小只有4K左右，给开发带来了诸多不便。但是Web存储需要更加的安全与快速。这些数据不会被保存在服务器上，但是这些数据只用于用户请求网站数据上。它也可以存储大量的数据，而不影响网站的性能。 数据以键值对存在，web网页的数据只允许该网页访问使用。 localStorage和sessionStorage客户端存储数据的两个对象： localStorage：用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去删除 sessionStorage：用于临时保存同以窗口的数据，在关闭窗口或标签页之后将会删除这些数据。 在使用web存储之前，应检查浏览器是否支持localStorage和sessionStorage 12345if(typeof(Storage)!==&quot;undefined&quot;)&#123; //支持localStorage sessionStorage对象&#125;esle&#123; //抱歉！不支持web存储。&#125; localStorage: localStorage对象存储的数据没有时间限制，第二天、第二周、下一年之后，数据依然可以使用。容量大小约为20M左右, 存储的数据不会随着用户浏览时会话过期而过期，但会应用户的请求而删除。浏览器也因为存储空间的限制或安全原因删除它们.而且类型存储的数据可以同一个浏览器的多个窗口共享 sessionStorage： sessionStorage方法针对一个session进行数据存储。当用户关闭浏览器窗口后，数据会被删除。(容量大小约为5M左右,该方式的生命周期为关闭浏览器窗口为止) API： 不管是localStorage还是sessionStorage，可使用相同的API，常用的有一下几个(以localStorage为例): 保存数据：localStorage.setItem(key,value) 读取数据：localStorage.getItem(key) 删除单个数据：localStorage.remove(key) 删除所有的数据：localStorage.clear(); 得到某个索引的key：localStorage.key(index); 注意：只要存储字符串，如果是json对象的话，可以将对象JSON.toString()转换后存储。","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"HTML5","slug":"前端学习栈/HTML5","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/HTML5/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://mgy1021.github.io/tags/HTML5/"}]},{"title":"原型与原型链","slug":"原型与原型链","date":"2021-10-28T06:55:20.000Z","updated":"2021-10-28T06:55:58.263Z","comments":true,"path":"2021/10/28/原型与原型链/","link":"","permalink":"https://mgy1021.github.io/2021/10/28/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"原型与原型链什么是原型？在javaScript中，我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype。这个属性对应着一个对象，这个对象就是我们所谓的原型对象。 如果函数作为普通函数调用prototype没有任何作用。 当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象，我们可以通过__proto__来访问该属性。 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。 检测使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true 1console.log(&quot;a&quot; in mc) hasOwnProperty可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性。使用该方法只有当对象中含有属性时，才会返回true 1mc.hasOwnProperty(&quot;name&quot;) 什么是原型链？__proto__和constructor每一个对象数据类型(普通对象、实例、prototype)也天生自带一个属性__proto__，属性值是当前实例所属类的原型(prototype)。原型对象中有一个属性constructor，它指向函数对象。 原型链在JavaScript中万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。 原型对象也是对象，所以它也有原型： 当我们使用一个对象的属性或方法时，会先在自身中寻找，自身中如果有，则直接使用，如果没有则去原型对象中寻找，如果原型对象中有，则直接使用，如果原型对象中没有，则去原型对象的原型中寻找。直到找到Object对象的原型，Object对象的原型没有原型，如果在Object中依然没有找到，则返回undefined。 以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性个方法。","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"JavaScript","slug":"前端学习栈/JavaScript","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://mgy1021.github.io/tags/JavaScript/"}]},{"title":"时间冒泡与事件委托","slug":"时间冒泡与事件委托","date":"2021-10-28T06:53:52.000Z","updated":"2021-10-28T06:54:41.848Z","comments":true,"path":"2021/10/28/时间冒泡与事件委托/","link":"","permalink":"https://mgy1021.github.io/2021/10/28/%E6%97%B6%E9%97%B4%E5%86%92%E6%B3%A1%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/","excerpt":"","text":"事件冒泡​ 所谓的事件冒泡是指事件向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发。 1234567891011121314151617181920212223242526272829 &lt;div id=&quot;box1&quot;&gt; &lt;div id=&quot;box2&quot;&gt; &lt;div id=&quot;box3&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var box1 = document.getElementById(&quot;box1&quot;) box1.onclick = function (e) &#123; console.log(&quot;我是box1&quot;); &#125; var box2 = document.getElementById(&quot;box2&quot;) box2.onclick = function (e) &#123; // e.cancelBubble = true console.log(&quot;我是box2&quot;); &#125; var box3 = document.getElementById(&quot;box3&quot;) box3.onclick = function () &#123; console.log(&quot;我是box3&quot;); &#125; &lt;/script&gt; &lt;!-- 当点击最里层的box3元素时，输出结果为：我是box3我是box2我是box1--&gt; 阻止事件冒泡的方法​ 在开发中大部分情况冒泡都是有用的，如果不希望发生事件冒泡可以通过事件对象来取消冒泡。 event.cancelBubble设置event对象中的cancelBubble属性为true可以取消事件冒泡行为。注意：cancelBubble是IE的属性， 所有浏览器都支持，不存在兼容性。 123456789101112131415161718&lt;script&gt; var box1 = document.getElementById(&quot;box1&quot;) box1.onclick = function (e) &#123; console.log(&quot;我是box1&quot;); &#125; var box2 = document.getElementById(&quot;box2&quot;) box2.onclick = function (e) &#123; console.log(&quot;我是box2&quot;); e.cancelBubble = true &#125; var box3 = document.getElementById(&quot;box3&quot;) box3.onclick = function (e) &#123; console.log(&quot;我是box3&quot;); e.cancelBubble = true &#125;&lt;/script&gt; event.stopPropagationstopPropagation() 方法防止调用相同事件的传播。传播意味着向上冒泡到父元素或向下捕获到子元素。 事件的委派​ 事件委派指将事件统一绑定给元素共同的祖先元素，这样后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。 ​ 注意：事件委派是利用了冒泡的机制，通过委派可以减少事件绑定的次数，提高程序的性能。 事件的传播​ 关于事件的传播网景公司和微软公司有不同的理解： 微软公司认为事件应该是由内向外传播的，也就是当事件触发时，应该先触发当前元素上的事件，然后再向外传播。 网景公司认为事件应该是由外向内传播的，也就是当事件触发时，应该先触发当前元素的最外层的祖先元素的事件，然后再向内传播。 W3C综合了两个公司的方案，将事件传播分为三个阶段： 捕获阶段 在捕获阶段时从最外层的祖先元素，向目标元素进行事件捕获，但是默认此时不会触发事件。 目标阶段 事件捕获到目标元素时，捕获结束开始在目标元素上触发事件。 冒泡阶段 事件从目标元素向他的祖先元素传递，一次触发祖先元素上的事件 注意：如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true。一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般是false。IE8及以下的浏览器没有捕获阶段。","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"JavaScript","slug":"前端学习栈/JavaScript","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://mgy1021.github.io/tags/JavaScript/"}]},{"title":"垃圾回收机制","slug":"垃圾回收机制","date":"2021-10-28T06:51:20.000Z","updated":"2021-10-28T06:53:17.990Z","comments":true,"path":"2021/10/28/垃圾回收机制/","link":"","permalink":"https://mgy1021.github.io/2021/10/28/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/","excerpt":"","text":"垃圾回收(GC)程序运行过程中会产生垃圾，这些垃圾积攒过多以后，会导致程序运行的速度过慢，所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生的垃圾。 什么是程序中的垃圾？当一个对象没有任何的变量或者属性对它进行引用，此时我们将永远无法进行操作该对象，此时这种对象就是一种垃圾。这种对象过多会占用大量的内存空间，导致程序运行变慢，所必须进行垃圾清理。 怎么清理程序中的垃圾?在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收操作。","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"JavaScript","slug":"前端学习栈/JavaScript","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://mgy1021.github.io/tags/JavaScript/"}]},{"title":"数据类型","slug":"数据类型","date":"2021-10-28T06:42:00.000Z","updated":"2021-10-28T06:50:37.737Z","comments":true,"path":"2021/10/28/数据类型/","link":"","permalink":"https://mgy1021.github.io/2021/10/28/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"基本数据类型和数据类型检测基本数据类型在JS中有5种基本数据类型和1种引用数据类型。ECMAscript不支持任何创建自定义类型的机制，而所有值最终都将是上述6种数据类型之一. 5种基本数据类型： Number String Boolean Undefined Null Boolean: 需要注意的是，Boolean类型的字面值true和false是区分大小写的。也就是说，True和False(以及其他的混合大小写形式)都不是Boolean值，只是标识符。 将一个值转换为其对应的Boolean值，可以调用转型函数Boolean()，返回的值取决于要转换值的数据类型及其实际值。 数据类型 转换为true的值 转换为false的值 Boolean true false Number 任何非零数字值 0或者NaN String 非空字符串 “”（空字符串） Object 任何对象 null Undefined n/a undefined NaN: NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。 Number数值的转换: 有3个函数可以把非数值转换为数值：Number()、parseInt()、parseFloat().第一个函数可以用于任何的数据类型，后面两个函数则只能用于字符串转数值。这3个函数对于同样的输入会有返回不同的结果。 Number() 如果是Boolean值,true和false分别转换为1和0 如果是数字值类型，只是简单的传入和返回 如果是null值，返回0 如果是undefined，返回NaN 如果是字符串，遵循下列规则： 如果字符串只包含数字，则将其转换为十进制数值，注意”011“会转换为11(前面的0会被忽略) 如果字符串中包含有效的浮点样式，如”1.1“，则将其转换为其对应的浮点数值(同样忽略前面的0) 如果字符串中包含有效的十六进制格式，例如”0xf”，则将其转换为相同大小的十进制整数值 如果字符串是空的（不包含任何字符），则将其转换为 0； 如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。 如果是对象，则调用对象的 valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN，则调用对象的 toString()方法，然后再次依照前面的规则转换返回的字符 串值。 parseInt() parseInt()方法会从第一个字符开始解析，如果第一个字符是非数字字符或者不是减号，则返回NaN。如果第一个字符是数字字符，则会继续解析下一个字符，直到检测到一个非数字字符为止。并且parseInt()也能够识别出各种整数格式(八进制、十六进制)。 parseFloat() 除了第一个小数点有效之外，parseFloat()与 parseInt()的第二个区别在于它始终都会忽略前导的零。parseFloat()可以识别前面讨论过的所有浮点数值格式，也包括十进制整数格式。但十六进制格式的字符串则始终会被转换成 0。由于 parseFloat()只解析十进制值，因此它没有用第二个参数指定基数的用法。最后还要注意一点：如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后都是零），parseFloat()会返回整数. 1种引用数据类型： Object Object类型 Object的每个实例都具有下列属性和方法。 constructor:保存着用于创建当前对象的函数。 hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中是否存在(而不是在实例的原型中)，其中，作为参数的属性名(propertyName)必须以字符串形式指定 isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型 toLocalString()：返回对象的字符串表示，该字符串与执行环境那个的地区对应。 toString()：返回对象的字符串表示。 valueOf()：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同 对象的分类： 内置对象 由ES标准中定义的对象，在任何的ES的实现中都可以用 比如：String(),Number(),Function,Object等等 宿主对象 由JS的运行环境提供的对象，目前来讲主要指浏览器提供的对象 比如BOM，DOM 自定义对象 由开发人员自己创建的对象 函数： 函数也是一个对象 创建函数的方式： 使用构造函数创建： 1var fun = new Function(&quot;console.log(Hello 我是一个函数)&quot;) 使用函数声明创建: 123function 函数名([形参1,...])&#123; //函数体&#125; 使用函数表达式创建一个对象： 123var fun3 = function()&#123; console.log(&quot;我是匿名函数中封装的代码!&quot;)&#125; 全局作用域： 直接编写在script标签中的JS代码，都在全局作用域 全局作用域在页面打开时创建，在页面关闭的时候销毁 在全局作用域中有一个全局对象Window，它代表的时一个浏览器的窗口，它由浏览器创建我们可以直接使用。 在全局作用域中，创建的变量都会作为window对象的属性保存。 当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用。如果没有则向上一级作用域中寻找，直到找到全局作用域，如果全局作用域中依然没有，则会报错。 函数作用域： 调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁。 每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的。 在函数作用域中可以访问到全局的变量，在全局作用域中无法访问到局部作用域的变量。 在函数中要访问全局变量可以使用window对象。 在函数作用域中也有声明提前，会在函数所有的代码执行之前声明 没有使用var声明的变量，都会声明成为全局变量 变量的声明提前： 使用var关键字声明的变量，会在所有的代码执行之前被声明，不使用var关键字声明的变量不会被声明提前。 函数的声明提前： 使用函数声明形式创建的函数function(){}，它会在所有的代码执行之前就被创建，所以可以在函数声明之前调用函数。 注意：使用函数表达式声明的函数不会声明提前。 数据类型检测数据类型检测的方法： typeof instanceof toString 1.typeoftypeof操作符是确定一个变量是字符串，数字，布尔值，还是undefined的最佳工具。但是如果变量的值是一个对象或null，则typeof操作符会返回“Object”. 注意： typeof检测null会返回Object,因为null被认为是一个空对象的引用 Chrome7及之前版本在对正则表达式调用typeof操作符时会返回”function“，而其他浏览器在这种情况下回返回”Object“. 对未初始化和未声明的变量执行 typeof 操作符都返回 undefined 值","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"JavaScript","slug":"前端学习栈/JavaScript","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://mgy1021.github.io/tags/JavaScript/"}]},{"title":"了解浏览器的内核","slug":"了解浏览器的内核","date":"2021-10-28T06:23:51.000Z","updated":"2021-10-28T06:25:02.418Z","comments":true,"path":"2021/10/28/了解浏览器的内核/","link":"","permalink":"https://mgy1021.github.io/2021/10/28/%E4%BA%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%86%85%E6%A0%B8/","excerpt":"","text":"浏览器的内核浏览器的内核是分为两个部分的，一是渲染引擎，另一个是JS引擎。现在JS引擎比较独立，内核更加倾向于说渲染引擎。 1、Trident内核：（三叉戟）代表作品是IE，因IE捆绑在Windows中，所以占有极高的份额，又称为IE内核或MSHTML，此内核只能用于Windows平台，且不是开源的。 代表作品还有腾讯、Maxthon（遨游）、360浏览器等。但由于市场份额比较大，曾经出现脱离了W3C标准的时候，同时IE版本比较多， 存在很多的兼容性问题。 2、Gecko内核：（壁虎）代表作品是Firefox，即火狐浏览器。因火狐是最多的用户，故常被称为firefox内核它是开源的，最大优势是跨平台，在Microsoft Windows、Linux、MacOs X等主 要操作系统中使用。 Mozilla是网景公司在第一次浏览器大战败给微软之后创建的。有兴趣的同学可以了解一下浏览器大战 3、Webkit内核：（引擎）代表作品是Safari、曾经的Chrome，是开源的项目。 4、Presto内核：（说变就变）代表作品是Opera，Presto是由Opera Software开发的浏览器排版引擎，它是世界公认最快的渲染速度的引擎。在13年之后，Opera宣布加入谷歌阵营，弃用了 Presto 5、Blink内核：（闪亮）由Google和Opera Software开发的浏览器排版引擎，2013年4月发布。现在Chrome内核是Blink。谷歌还开发了自己的JS引擎，V8，使JS运行速度极大地提高了","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"浏览器","slug":"前端学习栈/浏览器","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器内核","slug":"浏览器内核","permalink":"https://mgy1021.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/"}]},{"title":"frp内网穿透","slug":"frp内网穿透","date":"2021-10-28T06:15:23.000Z","updated":"2021-10-28T06:17:17.552Z","comments":true,"path":"2021/10/28/frp内网穿透/","link":"","permalink":"https://mgy1021.github.io/2021/10/28/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","excerpt":"","text":"frp内网穿透一、下载frp下载frp，放到两台服务器中。 官网：https://gofrp.org/docs/ 二、使用 在具有公网 IP 的机器上部署 frps，修改 frps.ini 文件，这里使用了最简化的配置，设置了 frp 服务器用户接收客户端连接的端口： 123[common]bind_port = 7000 ## 客户端连接服务端的端口号# token = @dad##.55da 在需要被访问的内网机器上（SSH 服务通常监听在 22 端口）部署 frpc，修改 frpc.ini 文件，假设 frps 所在服务器的公网 IP 为 x.x.x.x： 123456789101112131415161718192021222324252627[common]server_addr = x.x.x.x ## 服务端的公网ip 也可以是服务器的域名地址server_port = 7000 ## 客户端连接服务端的端口号# token = @dad##.55da[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 6000## `local_ip` 和 `local_port` 配置为本地需要暴露到公网的服务地址和端口。`remote_port` 表示在 frp 服务端监听的端口，访问此端口的流量将会被转发到本地服务对应的端口。## ssh -oPort=6000 test@x.x.x.x## frp 会将请求 x.x.x.x:6000 的流量转发到内网机器的 22 端口。[web]type = httplocal_port = 80custom_domains = www.yourdomain.com[web2]type = httplocal_port = 8080custom_domains = www.yourdomain2.com## 将 www.yourdomain.com 和 www.yourdomain2.com 的域名 A 记录解析到 IP x.x.x.x，如果服务器已经有对应的域名，也可以将 CNAME 记录解析到服务器原先的域名。或者可以通过修改 HTTP 请求的 Host 字段来实现同样的效果。## 通过浏览器访问 http://www.yourdomain.com:8080 即可访问到处于内网机器上 80 端口的服务，访问 http://www.yourdomain2.com:8080 则访问到内网机器上 8080 端口的服务。 编写配置文件，先通过 ./frps -c ./frps.ini 启动服务端，再通过 ./frpc -c ./frpc.ini 启动客户端。 注意：客户端是内网服务器，服务端是公开的服务器。","categories":[{"name":"服务器相关","slug":"服务器相关","permalink":"https://mgy1021.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3/"},{"name":"内网穿透","slug":"服务器相关/内网穿透","permalink":"https://mgy1021.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"}],"tags":[{"name":"内网穿透","slug":"内网穿透","permalink":"https://mgy1021.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"}]},{"title":"apidoc生成接口文档","slug":"apidoc生成接口文档","date":"2021-10-28T05:56:05.000Z","updated":"2021-10-28T05:59:46.524Z","comments":true,"path":"2021/10/28/apidoc生成接口文档/","link":"","permalink":"https://mgy1021.github.io/2021/10/28/apidoc%E7%94%9F%E6%88%90%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/","excerpt":"","text":"apidoc本篇文章记录一下在express中使用apidoc自动生成接口文档 官网：https://apidocjs.com/ 一、安装1npm install apidoc -g 二、配置文件 可以在项目根目录底下新建apidoc.json文件进行配置，基础配置如下： 1234567&#123; &quot;name&quot;: &quot;example&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;description&quot;: &quot;apiDoc basic example&quot;, &quot;title&quot;: &quot;Custom apiDoc browser title&quot;, &quot;url&quot; : &quot;https://api.github.com/v1&quot;&#125; 在node.js项目中可以在package.json文件中进行配置,把配置加入package.json文件中,配置如下： 1234567&quot;apidoc&quot;: &#123; &quot;name&quot;: &quot;系统接口文档&quot;, &quot;version&quot;: &quot;1.2.3&quot;, &quot;description&quot;: &quot;文档总描述&quot;, &quot;title&quot;: &quot;接口文档&quot;, &quot;url&quot;: &quot;http://192.168.2.81:3000&quot; &#125; 三、填写注解在接口前面注解，例如: 12345678910111213141516171819202122232425/** * @api &#123;get&#125; /user/:id Request User information * @apiName GetUser * @apiGroup User * * @apiParam &#123;Number&#125; id Users unique ID. * * @apiSuccess &#123;String&#125; firstname Firstname of the User. * @apiSuccess &#123;String&#125; lastname Lastname of the User. * * @apiSuccessExample Success-Response: * HTTP/1.1 200 OK * &#123; * &quot;firstname&quot;: &quot;John&quot;, * &quot;lastname&quot;: &quot;Doe&quot; * &#125; * * @apiError UserNotFound The id of the User was not found. * * @apiErrorExample Error-Response: * HTTP/1.1 404 Not Found * &#123; * &quot;error&quot;: &quot;UserNotFound&quot; * &#125; */ 四、运行-i后为入口文件，-o为输出文件s,运行成功后，会自动生成一个文件夹，点击打开就是接口文档。 1apidoc -i src -o apidoc","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"NodeJs","slug":"前端学习栈/NodeJs","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://mgy1021.github.io/tags/NodeJs/"},{"name":"apidoc","slug":"apidoc","permalink":"https://mgy1021.github.io/tags/apidoc/"}]},{"title":"pkg将node项目打包成exe可执行文件","slug":"pkg将node项目打包成exe可执行文件","date":"2021-10-28T05:45:51.000Z","updated":"2021-10-28T05:59:16.443Z","comments":true,"path":"2021/10/28/pkg将node项目打包成exe可执行文件/","link":"","permalink":"https://mgy1021.github.io/2021/10/28/pkg%E5%B0%86node%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E6%88%90exe%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/","excerpt":"","text":"pkg将node项目打包成exe可执行文件​ 在做大创项目时，需要将node项目移到其他地方运行，我想到了把node项目和node环境一起打包成exe可执行文件。这样就能实现在其他地方即使没有node环境也能运行node项目。这时我了解到了pkg，但是我在使用pkg打包时，遇到了一个问题，就是打包使用了express框架的项目，打包会卡住。具体原因不知道，我猜应该是express的依赖文件太大，打包编译过程需要很长时间。 一、安装1npm install pkg --save-dev 二、配置在node项目的package.json文件中，添加pkg配置。注意：静态文件要写在assets中，否则将不会被打包编译，比如json配置文件。bin是默认打包编译的路径. 12345678&#123; &quot;bin&quot;: &quot;./app.js&quot;, &quot;pkg&quot;: &#123; &quot;assets&quot;: [ &quot;connection-org1.json&quot; ] &#125;&#125; 三、使用在项目根目录下执行命令，此时，将从package.json中的bin定义的文件进行打包，打包成功后会生成一个app.exe的文件。 1pkg -o app -t win package.json","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"NodeJs","slug":"前端学习栈/NodeJs","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://mgy1021.github.io/tags/NodeJs/"},{"name":"pkg","slug":"pkg","permalink":"https://mgy1021.github.io/tags/pkg/"},{"name":"exe","slug":"exe","permalink":"https://mgy1021.github.io/tags/exe/"}]},{"title":"理解浏览器的渲染原理","slug":"理解浏览器的渲染原理","date":"2021-10-06T02:55:50.000Z","updated":"2021-10-28T06:10:37.128Z","comments":true,"path":"2021/10/06/理解浏览器的渲染原理/","link":"","permalink":"https://mgy1021.github.io/2021/10/06/%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/","excerpt":"","text":"浏览器的内核浏览器的内核是指支持浏览器运行的最核心的程序，分为两个部分，一个是渲染引擎，一个是JS引擎。渲染引擎在不同的浏览器中也不是都相同。目前市面上常见的浏览器内核可以分为四种：Trident(IE)、Gecko(火狐)、Blink(Chrome、Opera)、Webkit(Safari)。 一道面试题引发的“血案”请说出：从用户在浏览器地址栏输入网址，到看到整个页面，中间过程发生了什么？ HTTP请求阶段 HTTP响应阶段 浏览器渲染阶段 页面加载的过程 浏览器根据DNS服务器得到域名的ip地址 向这个ip的服务器发送HTTP请求 服务器收到、处理并返回HTTP请求 浏览器得到返回内容 返回的内容其实就是一堆HTML格式的字符串，因为只有HTML格式浏览器才能正确解析，这是W3C的标准。接下来就是浏览器的渲染过程。 浏览器渲染过程浏览器渲染过程大体分为如下三部分： 1.浏览器解析三个东西： 一是HTML/SVG/XHTML,HTML字符串描述了一个页面的结构，浏览器会把HTML结构字符串解析转换为DOM树形结构。 二是CSS，解析CSS会产生CSS规则树，它和DOM结构比较像。 三是JavaScript脚本，等到javaScript脚本文件加载后，通过DOM API和CSSOM API来操作DOM tree 和CSS Rule Tree. 2.解析完成后，浏览器引擎会通过DOM Tree和CSS Rule Tree来构造Rendering Tree。 Rendering Tree 渲染树并不等同于DOM树，渲染树只会包括需要显示的节点和这些节点的样式信息。 CSS 的 Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个Element 然后，计算每个布局(Frame) 的位置，这又叫layout和reflow过程。 3.最后通过调用操作系统Native GUI的API绘制。重绘与回流（Reflow）1.重绘(Repaint)元素样式的改变(但宽高、大小、位置等不变 )。也就是说当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的。 比如：outline、visibility、color、background-color等 2.回流（重排）元素的大小或者位置发生了变化（当页面布局和几何信息发生变化的时候），触发了重新布局，导致渲染树重新计算布局和渲染。 如：添加或者删除DOM元素、元素的位置发生变化、元素的尺寸发生变化、内容发生变化（比如文本变化或图片被另一个不同尺寸对的图片所替代）、页面一开始渲染的时候（这个是无法避免的）；因为回流是根据视口的大小来计算元素的位置和大小的，所以浏览器的窗口尺寸变化也会引发回流… 注意：回流一定会触发重绘，而重绘不一定会回流。重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。 问题一：为什么操作DOM慢因为DOM是属于渲染引擎中的东西，而JS又是JS引擎中的东西。当我们通过JS操作DOM的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。操作DOM次数一多，也就等同于一直在进行线程之间的通信，并且操作DOM可能还会带来重绘和回流的情况，所以也就导致了性能上的问题。 问题二：浏览器如果渲染过程中遇到JS文件怎么处理？渲染过程中，如果遇到&lt;script&gt;就停止渲染，执行JS代码。因为浏览器由GUI渲染线程与js引擎线程，为了放置渲染出现不可预期的结果，这两个线程是互斥的关系。JavaScript的加载、解析与执行会阻塞DOM的构建，也就是说，在构建DOM时，HTML解析器如果遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等javaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。 也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性 JS文件不只是阻塞DOM的构建，它会导致CSSOM也阻塞DOM的构建。 原本DOM和CSSOM的构建是互不影响，井水不犯河水，但是一旦引入了JavaScript，CSSOM也开始阻塞DOM的构建，只有CSSOM构建完毕后，DOM再恢复DOM构建。 原因在此：这是因为JavaScript不只是可以改DOM，它还可以更改样式，也就是它可以更改CSSOM。因为不完整的CSSOM是无法使用的，如果JavaScript想访问CSSOM并更改它，那么在执行JavaScript时，必须要能拿到完整的CSSOM。所以就导致了一个现象，如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和DOM构建，直至其完成CSSOM的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM。 问题三：渲染页面时常见哪些不良现象？由于浏览器的渲染机制不同，在渲染页面时会出现两种常见的不良现象–白屏问题和FOUS(无样式内容闪烁) FOUS：由于浏览器渲染机制(比如firedox)，再CSS加载之前，先呈现了HTML，就会导致展示出无样式内容，然后样式突然呈现的现象。 白屏：由于浏览器的渲染机制(比如chrome)要先构建DOM树和CSSOM树，构建完成后再进行渲染，如果CSS部分放在HTML尾部，由于CSS未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把js文件放在头部，脚本会阻塞后面内容的呈现，脚本会阻塞其后组件的下载，出现白屏问题。 总结 浏览器的工作流程：构建DOM–&gt;构建CSSOM–&gt;构建渲染树–&gt;布局–&gt;绘制 CSSOM会阻塞渲染，只有当CSSOM构建完成后才会进入下一个阶段构建渲染树 通常情况下DOM和CSSOM是并行构建的，但是当浏览器遇到一个script标签时，DOM构建将暂停，直至脚本完成执行。但由于JavaScript可以修改CSSOM，所以需要等CSSOM构建完毕后再执行JS。 如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，建议将 script 标签放在 body 标签底部。","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"浏览器","slug":"前端学习栈/浏览器","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"重绘回流","slug":"重绘回流","permalink":"https://mgy1021.github.io/tags/%E9%87%8D%E7%BB%98%E5%9B%9E%E6%B5%81/"},{"name":"浏览器渲染原理","slug":"浏览器渲染原理","permalink":"https://mgy1021.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/"}]},{"title":"Promise","slug":"Promise","date":"2021-09-30T08:00:52.000Z","updated":"2021-10-28T06:11:31.878Z","comments":true,"path":"2021/09/30/Promise/","link":"","permalink":"https://mgy1021.github.io/2021/09/30/Promise/","excerpt":"","text":"Promise的理解和使用1.什么是Promise1.1. 理解1.1.1.抽象表达： Promise是一门新的技术(ES6规范) Promise是JS中进行异步编程的新解决方案 备注：旧方案是单纯的使用回调函数 1.1.2.具体表达： 从语法上来说：Promise是一种构造函数 从功能上来说：Promise对象用来封装一个异步操作并可以获取其成功/失败的结果值。 异步编程包括： fs 文件操作 数据库操作 AJAX(网络请求) 定时器 2.为什么要用Promise2.1 指定回调函数的方式更加灵活 旧的：必须在启动异步任务前指定 promise：启动异步任务=&gt;返回promise对象=&gt;给promise对象绑定回调函数(甚至可以在异步任务结束后指定/多个) 2.2 支持链式调用，可以解决回调地狱问题 什么是回调地狱？ 回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回调执行的条件。 回调地狱的缺点 不便于阅读 不便于异常处理 解决方案 promise链式调用 3.Promise的使用3.1 Promise的简单使用promise是一种构造函数，Promise接收一个函数作为参数，这个函数里有两个参数，resolve和reject.如果异步操作成功执行resolve()函数，失败则执行reject。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;promise初体验&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;h2&gt;Promsie 初体验&lt;/h2&gt; &lt;button class=&quot;btn&quot;&gt;点击抽奖&lt;/button&gt; &lt;/div&gt; &lt;script&gt; // 生成随机数 function rand(m, n) &#123; return Math.ceil(Math.random() * (n - m + 1)) + m - 1 &#125; /* 点击按钮，2s后显示是否中奖(30%概率中奖) 若中奖弹出 恭喜恭喜，奖品为10万RMB 若不中奖弹出 再接再厉 */ var btn = document.getElementsByClassName(&quot;btn&quot;)[0] btn.onclick = function () &#123; // setTimeout(() =&gt; &#123; // // 获取从1-100的随机数 // let n = rand(1, 100) // if (n &lt;= 30) &#123; // alert(&quot;恭喜恭喜，奖品为10万RMB&quot;) // &#125; else &#123; // alert(&quot;再接再厉!!!&quot;) // &#125; // &#125;, 1000) // Promise形式实现 // resolve 解决 // reject 拒绝 const p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; // 获取从1-100的随机数 let n = rand(1, 100) if (n &lt;= 30) &#123; resolve(n) //将promise的状态变成成功 &#125; else &#123; reject(n) //将promise的状态设置为失败 &#125; &#125;, 1000) &#125;) // 调用then方法 p.then((res) =&gt; &#123; alert(`恭喜恭喜，奖品为10万RMB,您的中奖数字为：$&#123;res&#125;`) &#125;).catch((err) =&gt; &#123; alert(`再接再厉!!!你的号码为：$&#123;err&#125;`) &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.2 Promise状态值promise的状态是promise实例对象中的内置属性PromiseState，它可能的值为： pending 进行中(未决定的) resolve/fullfilled 成功 rejected 失败 当状态改变时只有两种可能： pending 变为 resolve pending 变为 reject 说明： 一个promise对象状态只能改变一次 无论变为成功还是失败，都会有一个结果数据 成功的结果数据一般为value，失败的结果数据一般称为reason 3.3 Promise对象的值promise实例对象中的另一个属性值PromiseResult，它保存的是异步任务成功/失败的结果。 修改PromiseResult值的方法： resolve() reject() 4.Promise的工作流程首先，我们需要通过new Promise()创建一个promise对象，在promise中封装异步操作，如果执行异步操作成功调用resolve改变promise为成功状态，否则调用reject改变promise为失败状态。如果promise为成功状态，则会自动调用.then()里面的回调函数。promise为失败状态，则调用.catch()里面的函数。最后返回一个新的promise对象。 5.Promise相关的API5.1 构造函数Promise(excutor){} excutor函数：执行器(resolve,reject)=&gt;{} resolve函数：内部定义成功时我们调用的函数value=&gt;{} reject函数：内部定义失败时我们调用的函数reason=&gt;{} 说明：executor会在Promise内部立即同步调用，异步操作在执行器中执行。 5.2 Promise.then()方法promise.then(onResolve,onReject) onResolve函数：成功的回调函数(value)=&gt;{} onReject函数：失败的回调函数(reason)=&gt;{} 说明：返回一个新的promise对象 5.3 Promise.catch()方法 onReject函数：失败的回调函数(reason)=&gt;{} 5.4 Promise.resolve()方法 value：成功的数据或promise对象 说明：返回一个成功/失败的promise对象 如果传入的参数为非promise对象，则返回一个成功的promise对象 如果传入一个promise类型的对象，则参数的结果决定了resolve的结果 5.5 Promise.reject()方法 reason：失败的原因 说明：返回一个失败的promise对象 5.6 Promise.all()方法 promise：包含n个Promise的数组 说明：返回一个新的promise，只有当数组中所有的promise都成功时才成功，只要有一个失败就直接失败。 结果是数组中promise的结果值组成的数组 5.7 Promise.race()方法 promise：包含n个Promise的数组 返回一个新的promise对象，第一个完成的promise的结果就是最终的结果 6.Promisify方法promisify是属于util模块的一个方法，如果使用Promise并不需要每一次都手动封装，可以使用util.promisify方法将回调函数风格的函数，转变成Promise风格的函数。 1234567const util = require(&quot;util&quot;)const fs = require(&quot;fs&quot;)// 返回一个新的函数let mineReadFile = util.promisify(fs.readFile);mineReadFile(&#x27;./resource/content.txt&#x27;).then(value =&gt; &#123; console.log(value.toString()); &#125;) 7.自定义封装Promise7.1 函数封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186/* * @Description: * @Author: Mogy * @Date: 2021-09-19 18:12:34 * @LastEditors: Mogy * @LastEditTime: 2021-09-30 14:55:51 */// 声明构造函数function Promise(executor) &#123; // 添加属性 this.PromiseState = &quot;pending&quot;; this.PromiseResult = null; // 声明一个属性存储回调函数 this.callBacks = [] // 保存实例对象this的值 const self = this // resolve函数 function resolve(data) &#123; // 判断状态 if (self.PromiseState !== &quot;pending&quot;) return // 1.修改对象的状态(promiseState) self.PromiseResult = data // 2.设置对象的结果值(promiseResult) self.PromiseState = &quot;fullfilled&quot; // 调用成功的回调 setTimeout(() =&gt; &#123; self.callBacks.forEach(item =&gt; &#123; item.onResolved(data) &#125;) &#125;) &#125; // reject函数 function reject(data) &#123; if (self.PromiseState !== &quot;pending&quot;) return // 1.修改对象的状态 self.PromiseState = &quot;rejected&quot; // 2.设置对象的结果值 self.PromiseResult = data // 调用失败的回调 setTimeout(() =&gt; &#123; self.callBacks.forEach(item =&gt; &#123; item.onRejected(data) &#125;) &#125;) &#125; try &#123; //同步调用执行器函数 executor(resolve, reject) &#125; catch (e) &#123; reject(e); &#125;&#125;// 添加then方法Promise.prototype.then = function (onResolved, onRejected) &#123; const self = this // 判断回调函数的参数 if (typeof onRejected !== &quot;function&quot;) &#123; onRejected = reason =&gt; &#123; throw reason &#125; &#125; if (typeof onResolved !== &quot;function&quot;) &#123; onResolved = value =&gt; &#123; return value &#125; &#125; return new Promise((resolve, reject) =&gt; &#123; // 封装函数 function callback(type) &#123; try &#123; // 获取函数的执行结果 let result = type(self.PromiseResult); if (result instanceof Promise) &#123; //如果是Promise类型的对象 result.then(v =&gt; &#123; resolve(v) &#125;, r =&gt; &#123; reject(r) &#125;) &#125; else &#123; //结果的对象状态为成功 resolve(result); &#125; &#125; catch (e) &#123; reject(e); &#125; &#125; // 调用回调函数 if (this.PromiseState === &quot;fullfilled&quot;) &#123; setTimeout(() =&gt; &#123; callback(onResolved) &#125;) &#125; if (this.PromiseState === &quot;rejected&quot;) &#123; setTimeout(() =&gt; &#123; callback(onRejected) &#125;) &#125; if (this.PromiseState === &quot;pending&quot;) &#123; // 保存回调函数 this.callBacks.push(&#123; onResolved: function () &#123; callback(onResolved) &#125;, onRejected: function () &#123; callback(onRejected) &#125; &#125;) &#125; &#125;)&#125;// 添加catch方法Promise.prototype.catch = function (onRejected) &#123; return this.then(undefined, onRejected);&#125;//添加resolve方法Promise.resolve = function (value) &#123; // 返回Promise对象 return new Promise((resolve, reject) =&gt; &#123; if (value instanceof Promise) &#123; value.then(v =&gt; &#123; resolve(v) &#125;, r =&gt; &#123; reject(r); &#125;) &#125; else &#123; // 状态设置为成功 resolve(value) &#125; &#125;)&#125;// 添加reject方法Promise.reject = function (reason) &#123; return new Promise((resolve, reject) =&gt; &#123; reject(reason) &#125;)&#125;// 添加all方法Promise.all = function (promises) &#123; //返回结果为promise对象 return new Promise((resolve, reject) =&gt; &#123; // 声明变量 let count = 0; let arr = []; // 遍历 for (let i = 0; i &lt; promises.length; i++) &#123; // promises[i].then(v =&gt; &#123; // 得知对象的状态是成功的 // 每个Promise对象都成功 count++; // 将当前promise对象成功的结果存入到数组中 arr[i] = v; // 判断 if (count == promises.length) &#123; // 修改状态 resolve(arr); &#125; &#125;, r =&gt; &#123; reject(r) &#125;) &#125; &#125;)&#125;// 添加race方法Promise.race = function (promises) &#123; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(v =&gt; &#123; // 修改返回对象的状态为成功 resolve(v) &#125;, r =&gt; &#123; // 修改返回对象的状态为成功 reject(r) &#125;) &#125; &#125;)&#125; 7.2 类封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187/* * @Description: * @Author: Mogy * @Date: 2021-09-19 18:12:34 * @LastEditors: Mogy * @LastEditTime: 2021-09-30 15:09:42 */class Promise &#123; //构造方法 constructor(executor) &#123; // 添加属性 this.PromiseState = &quot;pending&quot;; this.PromiseResult = null; // 声明一个属性存储回调函数 this.callBacks = [] // 保存实例对象this的值 const self = this // resolve函数 function resolve(data) &#123; // 判断状态 if (self.PromiseState !== &quot;pending&quot;) return // 1.修改对象的状态(promiseState) self.PromiseResult = data // 2.设置对象的结果值(promiseResult) self.PromiseState = &quot;fullfilled&quot; // 调用成功的回调 setTimeout(() =&gt; &#123; self.callBacks.forEach(item =&gt; &#123; item.onResolved(data) &#125;) &#125;) &#125; // reject函数 function reject(data) &#123; if (self.PromiseState !== &quot;pending&quot;) return // 1.修改对象的状态 self.PromiseState = &quot;rejected&quot; // 2.设置对象的结果值 self.PromiseResult = data // 调用失败的回调 setTimeout(() =&gt; &#123; self.callBacks.forEach(item =&gt; &#123; item.onRejected(data) &#125;) &#125;) &#125; try &#123; //同步调用执行器函数 executor(resolve, reject) &#125; catch (e) &#123; reject(e); &#125; &#125; // then方法 then(onResolved, onRejected) &#123; const self = this // 判断回调函数的参数 if (typeof onRejected !== &quot;function&quot;) &#123; onRejected = reason =&gt; &#123; throw reason &#125; &#125; if (typeof onResolved !== &quot;function&quot;) &#123; onResolved = value =&gt; &#123; return value &#125; &#125; return new Promise((resolve, reject) =&gt; &#123; // 封装函数 function callback(type) &#123; try &#123; // 获取函数的执行结果 let result = type(self.PromiseResult); if (result instanceof Promise) &#123; //如果是Promise类型的对象 result.then(v =&gt; &#123; resolve(v) &#125;, r =&gt; &#123; reject(r) &#125;) &#125; else &#123; //结果的对象状态为成功 resolve(result); &#125; &#125; catch (e) &#123; reject(e); &#125; &#125; // 调用回调函数 if (this.PromiseState === &quot;fullfilled&quot;) &#123; setTimeout(() =&gt; &#123; callback(onResolved) &#125;) &#125; if (this.PromiseState === &quot;rejected&quot;) &#123; setTimeout(() =&gt; &#123; callback(onRejected) &#125;) &#125; if (this.PromiseState === &quot;pending&quot;) &#123; // 保存回调函数 this.callBacks.push(&#123; onResolved: function () &#123; callback(onResolved) &#125;, onRejected: function () &#123; callback(onRejected) &#125; &#125;) &#125; &#125;) &#125; // catch方法 catch(onRejected) &#123; return this.then(undefined, onRejected); &#125; // resolve static resolve = function (value) &#123; // 返回Promise对象 return new Promise((resolve, reject) =&gt; &#123; if (value instanceof Promise) &#123; value.then(v =&gt; &#123; resolve(v) &#125;, r =&gt; &#123; reject(r); &#125;) &#125; else &#123; // 状态设置为成功 resolve(value) &#125; &#125;) &#125; // reject方法 static reject = function (reason) &#123; return new Promise((resolve, reject) =&gt; &#123; reject(reason) &#125;) &#125; // all方法 static all = function (promises) &#123; //返回结果为promise对象 return new Promise((resolve, reject) =&gt; &#123; // 声明变量 let count = 0; let arr = []; // 遍历 for (let i = 0; i &lt; promises.length; i++) &#123; // promises[i].then(v =&gt; &#123; // 得知对象的状态是成功的 // 每个Promise对象都成功 count++; // 将当前promise对象成功的结果存入到数组中 arr[i] = v; // 判断 if (count == promises.length) &#123; // 修改状态 resolve(arr); &#125; &#125;, r =&gt; &#123; reject(r) &#125;) &#125; &#125;) &#125; // race方法 static race = function (promises) &#123; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(v =&gt; &#123; // 修改返回对象的状态为成功 resolve(v) &#125;, r =&gt; &#123; // 修改返回对象的状态为成功 reject(r) &#125;) &#125; &#125;) &#125;&#125; 8.async与await8.1 async 函数的返回值为promise对象 promise对象的结果由async函数执行的返回值决定 如果返回值是一个非promise类型的数据,结果为成功的promise对象 如果返回的是一个promise对象,结果由返回的promise对象决定 抛出异常，结果为失败的promise对象，值为抛出的值 8.2 await表达式 await右侧的表达式一般为promise对象，但也可以是其他的值 如果表达式是promise对象，await返回的是promise成功的值 如果表达式是其他的值，直接将此值作为await的返回值 注意： await必须写在async函数中，但async函数中可以没有await 如果await的promise失败了，就会抛出异常，需要通过try…catch捕获处理","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"JavaScript","slug":"前端学习栈/JavaScript","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/JavaScript/"}],"tags":[{"name":"Promise","slug":"Promise","permalink":"https://mgy1021.github.io/tags/Promise/"}]},{"title":"SVG","slug":"SVG","date":"2021-09-14T08:33:42.000Z","updated":"2021-10-28T06:11:13.797Z","comments":true,"path":"2021/09/14/SVG/","link":"","permalink":"https://mgy1021.github.io/2021/09/14/SVG/","excerpt":"","text":"一、认识SVGsvg是一种基于XML语法的图像格式，全称是可缩放的矢量图。其他图像格式都是基于像素处理的，SVG则是属于对图像的形状描述，所以它本质上是文本文件，体积较小，且不管放大多少倍都不会失真。 SVG文件可以直接插入网页，成为DOM的一部分，然后用JavaScript和CSS进行操作。 二、使用SVG的多种方式 svg标签 img标签使用 iframe标签使用 object标签使用 embed标签使用 SVG代码页可以写在一个独立文件中，然后用img/object/iframe/embed等标签插入网页。 1234&lt;img src=&quot;./css/美国队长.svg&quot; alt=&quot;&quot;&gt;&lt;iframe src=&quot;./css/美国队长.svg&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;object data=&quot;./css/美国队长.svg&quot; type=&quot;image/svg+xml&quot;&gt;&lt;/object&gt;&lt;embed src=&quot;./css/美国队长.svg&quot; type=&quot;image/svg+xml&quot;&gt; 三、SVG的语法3.1 &lt;svg&gt;标签SVG代码都放在顶层标签&lt;svg&gt;中，下面是一个例子： 123&lt;svg width=&quot;100%&quot; height=&quot;100%&quot;&gt; &lt;circle id=&quot;mycircle&quot; cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;50&quot; fill=&quot;orange&quot;&gt;&lt;/circle&gt;&lt;/svg&gt; SVG的width属性和height属性，制定了SVG图像在HTML元素中锁占据的宽高。除了相对单位，也可以使用绝对单位(单位：像素)。如果不指定这两个属性，SVG图像默认大小是300px（宽）*150px（高）。 如果只想展示SVG图像的一部分，就要执行viewbox属性。 123&lt;svg width=&quot;100&quot; height=&quot;100&quot; viewbox=&quot;50 50 50 50&quot;&gt; &lt;circle id=&quot;mycircle&quot; cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;50&quot; fill=&quot;orange&quot;&gt;&lt;/circle&gt;&lt;/svg&gt; viewbox属性的值只有四个数字，分别是左上角的横坐标和纵坐标、视口的高度和宽度。上面的代码中，svg的图像是100px*100px，viewbox属性指定视口从(50,50)这个点开始。所以，实际看到的是右下角的四分之一圆。 3.2&lt;circle&gt;标签&lt;circle&gt;标签代表圆形。 123&lt;svg width=&quot;100%&quot; height=&quot;100%&quot;&gt; &lt;circle id=&quot;mycircle&quot; cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;50&quot; fill=&quot;orange&quot;&gt;&lt;/circle&gt;&lt;/svg&gt; cx代表圆心的x轴坐标,cy代表圆心的y轴坐标，r表示半径 stroke属性可以设置边框，stroke-width可以设置边框的宽度。 3.3&lt;line&gt;标签&lt;line&gt;标签可以用来绘制一条直线 123&lt;svg width=&quot;400px&quot; height=&quot;400px&quot;&gt; &lt;line x1=&quot;50&quot; y1=&quot;50&quot; x2=&quot;100&quot; y2=&quot;350&quot; style=&quot;stroke:red;stroke-width:3px&quot;&gt;&lt;/line&gt;&lt;/svg&gt; 3.4&lt;polyline&gt;标签&lt;polyline&gt;标签用于绘制一根折线。 123&lt;svg width=&quot;400px&quot; height=&quot;400px&quot;&gt; &lt;polyline points=&quot;50,100 200,300 350,300&quot; style=&quot;fill:none;stroke:deeppink;stroke-width:5px&quot;&gt;&lt;/polyline&gt;&lt;/svg&gt; 3.5&lt;rect&gt;矩形&lt;rect&gt;绘制一个矩形 123&lt;svg width=&quot;400&quot; height=&quot;400&quot;&gt; &lt;rect x=&quot;50&quot; y=&quot;50&quot; width=&quot;250&quot; height=&quot;250&quot; class=&quot;rect&quot;&gt;&lt;/rect&gt; &lt;/svg&gt; 3.6&lt;ellipse&gt;椭圆&lt;ellipse&gt;标签用于绘制椭圆 123&lt;svg width=&quot;400&quot; height=&quot;400&quot;&gt; &lt;ellipse cx=&quot;100&quot; cy=&quot;100&quot; ry=&quot;40&quot; rx=&quot;20&quot;&gt;&lt;/ellipse&gt; &lt;/svg&gt; 3.7polygon多边形123&lt;svg width=&quot;400&quot; height=&quot;400&quot;&gt; &lt;polygon points=&quot;50,50 350,350 50,350&quot;&gt;&lt;/polygon&gt;&lt;/svg&gt; 3.8&lt;path&gt;路径&lt;path&gt;用于绘制路径 123&lt;svg width=&quot;600&quot; height=&quot;600&quot;&gt; &lt;path d=&quot;M 100,50 L 100,60 L 60,60 L 250,300 L 450,450 Z&quot;&gt;&lt;/path&gt; &lt;/svg&gt; path的d属性表示绘制顺序，它的值是一个长字符串，每个字母表示一个绘制动作，后面跟着坐标。 M：移动到(moveto) L：画直线到(lineto) Z：闭合路径 3.9&lt;text&gt;绘制文本1&lt;text x=&quot;200&quot; y=&quot;400&quot;&gt;这是绘制路径&lt;/text&gt; 3.10&lt;use&gt;标签use用来复制一个形状 1234&lt;svg width=&quot;600&quot; height=&quot;600&quot;&gt; &lt;circle id=&quot;myCircle&quot; cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;50&quot; fill=&quot;orange&quot; stroke=&quot;red&quot; stroke-width=&quot;5px&quot;&gt;&lt;/circle&gt; &lt;use href=&quot;#myCircle&quot; x=&quot;200&quot; y=&quot;200&quot;&gt;&lt;/use&gt;&lt;/svg&gt; href属性指定所要复制的节点，x属性和y属性是左上角的坐标。另外，还可以指定width和height坐标。 3.11&lt;g&gt;标签&lt;g&gt;标签用于将多个形状组成一个组(group)，方便服用。 12345678910&lt;svg width=&quot;1500px&quot; height=&quot;1500px&quot;&gt; &lt;defs&gt; &lt;g id=&quot;miqi&quot;&gt; &lt;circle cx=&quot;100&quot; cy=&quot;100&quot; r=&quot;50&quot;&gt;&lt;/circle&gt; &lt;circle cx=&quot;500&quot; cy=&quot;100&quot; r=&quot;50&quot;&gt;&lt;/circle&gt; &lt;circle cx=&quot;300&quot; cy=&quot;300&quot; r=&quot;200&quot;&gt;&lt;/circle&gt; &lt;/g&gt; &lt;/defs&gt; &lt;use href=&quot;#miqi&quot; x=&quot;500&quot; y=&quot;0&quot;&gt;&lt;/use&gt;&lt;/svg&gt; 3.12&lt;pattern&gt;标签&lt;pattern&gt;标签用于自定义一个形状，该形状可以被引用来平铺一个区域。 12345678&lt;svg width=&quot;500&quot; height=&quot;500&quot;&gt; &lt;defs&gt; &lt;pattern id=&quot;dots&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;100&quot; patternUnits=&quot;userSpaceOnUse&quot;&gt; &lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;35&quot; fill=&quot;#bee9e8&quot;&gt;&lt;/circle&gt; &lt;/pattern&gt; &lt;/defs&gt; &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;url(#dots)&quot;&gt;&lt;/rect&gt; &lt;/svg&gt; 3.13&lt;animate&gt;标签1234567&lt;svg width=&quot;1000&quot; height=&quot;1000&quot;&gt; &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;50&quot; fill=&quot;orange&quot;&gt; &lt;animate attributeName=&quot;x&quot; from=&quot;0&quot; to=&quot;500&quot; dur=&quot;2s&quot; repeatCount=&quot;indefinite&quot;&gt;&lt;/animate&gt; &lt;animate attributeName=&quot;y&quot; from=&quot;0&quot; to=&quot;500&quot; dur=&quot;2s&quot; repeatCount=&quot;indefinite&quot;&gt;&lt;/animate&gt; &lt;animate attributeName=&quot;fill&quot; from=&quot;orange&quot; to=&quot;skyblue&quot; dur=&quot;2s&quot; repeatCount=&quot;indefinite&quot;&gt;&lt;/animate&gt; &lt;/rect&gt; &lt;/svg&gt; animate的属性含义如下： attributeName:发生动画效果的属性名 from：单次动画的初始值 to：单次动画的结束值 dur：单词动画持续的时间 repeatCount：动画的循环模式","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"CSS","slug":"前端学习栈/CSS","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://mgy1021.github.io/tags/CSS/"},{"name":"SVG","slug":"SVG","permalink":"https://mgy1021.github.io/tags/SVG/"}]},{"title":"Workers","slug":"Web Workers","date":"2021-09-12T10:50:55.000Z","updated":"2021-09-12T10:52:28.364Z","comments":true,"path":"2021/09/12/Web Workers/","link":"","permalink":"https://mgy1021.github.io/2021/09/12/Web%20Workers/","excerpt":"","text":"Web Workers​ Web Workers是HTML5提供的一个JavaScript多线程解决方案。我们可以将一些大计算量的代码交由Web Worker运行而不冻结用户界面。 但是子线程完全受主线程控制，且不得操作DOM。所以这个新标准并没有改变JavaScript单线程的本质。 使用：1.创建HTML文件Web Workers.html12345678910111213141516171819202122232425262728293031323334353637383940&lt;!-- * @Description: * @Author: Mogy * @Date: 2021-09-08 15:20:06 * @LastEditors: Mogy * @LastEditTime: 2021-09-08 15:59:50--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input id=&quot;number&quot; type=&quot;text&quot; placeholder=&quot;数值&quot;&gt; &lt;button id=&quot;btn&quot;&gt;计算&lt;/button&gt; &lt;script&gt; var input = document.getElementById(&quot;number&quot;) document.getElementById(&quot;btn&quot;).onclick = function () &#123; var number = input.value // 创建一个Worker对象 var worker = new Worker(&quot;worker.js&quot;) // 绑定接收消息的监听 worker.onmessage = function (event) &#123; console.log(&quot;主线程接收分线程返回的数据&quot; + event.data); alert(event.data) &#125; // 向分线程发送消息 worker.postMessage(number) console.log(&quot;主线程向分线程发送数据：&quot; + number); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.创建一个分线程文件worker.js​ 注意：分线程中的全局对象并不是window，所以分线程无法更新页面 1234567891011121314151617181920212223242526272829/* * @Description: * @Author: Mogy * @Date: 2021-09-08 15:42:30 * @LastEditors: Mogy * @LastEditTime: 2021-09-08 15:53:38 */// 创建一个Worker对象并向它传递将在新线程中执行的脚本的URL// var worker = new Worker(&quot;worker.js&quot;);// 接收worker传过来的数据函数// worker.onmessage = function (event) &#123;// console.log(event.data);// &#125;// 向worker发送数据// worker.postMessage(&quot;hello world&quot;)function fibonacci(n) &#123; return n &lt;= 2 ? 1 : fibonacci(n - 1) + fibonacci(n - 2);&#125;var onmessage = function (event) &#123; var number = event.data console.log(&quot;分线程接收到主线程发送的数据&quot; + number); // 计算 var result = fibonacci(number) postMessage(result) console.log(&quot;分线程向主线程返回数据&quot; + result);&#125; Web Workers的不足之处 慢 不能跨域加载JS worker内代码不能访问DOM(更新UI) 不是每个浏览器都支持这个新特性","categories":[],"tags":[{"name":"workers","slug":"workers","permalink":"https://mgy1021.github.io/tags/workers/"},{"name":"多线程","slug":"多线程","permalink":"https://mgy1021.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"防抖与节流","slug":"防抖与节流","date":"2021-09-12T10:43:51.000Z","updated":"2021-10-28T06:09:02.217Z","comments":true,"path":"2021/09/12/防抖与节流/","link":"","permalink":"https://mgy1021.github.io/2021/09/12/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/","excerpt":"","text":"防抖和节流的使用场景防抖和节流是针对响应跟不上触发频率这类问题的两种解决方案。在给DOM绑定事件时，有些事件我们是无法控制触发频率的。如鼠标移动事件onmousemove，滚动滚动条事件onscroll,窗口大小改变事件onresize,瞬间的操作都会导致这些事件会被高频触发。如果回调函数较为复杂，就会导致响应跟不上触发，出现页面卡顿，假死现象。比如，在实时检查输入时，如果我们绑定onkeyup事件发请求去服务端检查，用户输入过程中，事件的触发频率也会很高，会导致大量的请求发出，响应速度会大大跟不上触发。 针对此类快速连续触发和不可控的高频触发问题，debounce 和 throttling 给出了两种解决策略。 防抖(debounce)​ debounce的特点是当事件快速连续不断触发时，动作只会执行一次。 延迟debounce，是在周期结束时执行，前缘debounce，是在周期开始时执行。但当触发有间断，且间断大于我们设定的时间间隔时，动作就会有多次执行。 延迟debounce防抖的策略是当事件被触发时，设定一个周期延迟执行动作，若期间又被触发，则重新设定周期，直到周期结束，执行动作，这是防抖的基本思想。 前缘debounce前缘debounce,即执行动作在前，然后设定周期，周期内有事件被触发，不执行动作，且周期重新设定。 防抖的简单实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!-- * @Description: * @Author: Mogy * @Date: 2021-09-09 09:38:27 * @LastEditors: Mogy * @LastEditTime: 2021-09-09 11:45:38--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;防抖&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot;&gt; &lt;script&gt; // 防抖：用户触发事件过于频繁，只要最后一次事件的操作 var input = document.querySelector(&#x27;input&#x27;) // 简单实现 // let time = null // input.onkeyup = function () &#123; // if (time != null) &#123; // clearTimeout(time) // &#125; // time = setTimeout(() =&gt; &#123; // console.log(this.value); // &#125;, 500) // &#125; // 使用闭包封装 input.onkeyup = debounce(function () &#123; console.log(this.value); &#125;, 500) function debounce(fn, delay) &#123; let time = null return function () &#123; if (time !== null) &#123; clearTimeout(time); &#125; time = setTimeout(() =&gt; &#123; fn.call(this); &#125;, delay); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 节流(throttling)节流的策略是，固定周期内，只执行一次动作，若有新事件触发，不执行。周期结束后，又有事件触发，开始新的周期。 节流策略也分前缘和延迟两种。与debounce类似，延迟是指 周期结束后执行动作，前缘是指执行动作后再开始周期。 延迟throttling示意图： 前缘throttling 示意图： 节流的简单实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!-- * @Description: * @Author: Mogy * @Date: 2021-09-09 10:20:39 * @LastEditors: Mogy * @LastEditTime: 2021-09-09 10:28:54--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;节流&lt;/title&gt; &lt;style&gt; body &#123; height: 2000px; &#125; &lt;/style&gt; &lt;script&gt; // 节流:控制高频事件执行次数 window.onscroll = throttle(function () &#123; console.log(&quot;hello word&quot;); &#125;, 500) function throttle(fn, delay) &#123; let flag = true; return function () &#123; if (flag) &#123; setTimeout(() =&gt; &#123; fn.call(this) flag = true &#125;, delay) &#125; flag = false; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"JavaScript","slug":"前端学习栈/JavaScript","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://mgy1021.github.io/tags/JavaScript/"},{"name":"防抖与节流","slug":"防抖与节流","permalink":"https://mgy1021.github.io/tags/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"}]},{"title":"线程机制与事件机制","slug":"线程机制与事件机制","date":"2021-09-08T06:40:05.000Z","updated":"2021-10-28T06:10:10.883Z","comments":true,"path":"2021/09/08/线程机制与事件机制/","link":"","permalink":"https://mgy1021.github.io/2021/09/08/%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/","excerpt":"","text":"进程与线程进程(process)​ 程序的一次执行，它占有了一片独有的内存空间。可以通过Window任务管理器查看进程。 线程(thread)​ 线程是进程内的一个概念，线程是进程内的一个独立执行单元，是程序执行的一个完整流程，是CPU的最小的调度单元。 JS是一门单线程语言,但是使用H5中的Web Workers可以多线程运行。浏览器运行是多线程的 单进程浏览器(firefox,老版IE)，多进程浏览器(chrome,新版IE) 相关知识 应用程序必须运行在某个进程的某个线程上 一个进程中至少有一个运行的线程：主线程，进程启动后自动创建 一个进程中也可以同时运行多个线程，我们会说程序是多线程运行的 一个进程内的数据可以供其中的多个线程直接共享 多个进程之间的数据是不能直接共享的 线程池(thread pool):保存多个线程对象的容器，实现线程对象的反复利用。 浏览器内核什么是浏览器内核？支撑浏览器运行的最核心的程序。不同浏览器可能不一样，内核由很多模块组成。模块有： JS引擎模块：负责js程序的编译与运行 html，css文档解析模块：负责页面文本的解析 DOM/CSS模块：负责dom/css在内存中的相关处理（生成DOM对象树） 布局和渲染模块：负责页面的布局和效果的绘制（内存中的对象） 定时器模块：负责定时器的管理 事件响应模块：负责事件的管理 网络请求模块：负责ajax请求 等等 JS代码分类和执行顺序JS代码分类 同步代码 回调代码 JS引擎执行代码的基本流程 先执行同步代码 设置定时器 绑定监听 发送ajax请求 后面在某个时刻才会执行回调代码 浏览器的事件循环机制JS是单线程的，非阻塞的1.单线程​ JS是单线程的，或者说只有一个主线程，也就是说它只能执行一段代码。所谓的单线程也只是相对于多线程而言。JS的设计初衷就没有考虑这些，针对JS这种不具备并行任务处理的特性，我们称之为“单线程”。 JavaScript的主要用途是与用户互动，以及操作DOM。如果它是多线程的会有很多复杂的问题要处理，比如有两个线程同时操作DOM，一个线程删除了当前的DOM节点，一个线程是要操作当前的DOM阶段，最后以哪个线程的操作为准？为了避免这种，所以JS是单线程的。即使H5提出了web worker标准，它有很多限制，受主线程控制，是主线程的子线程。 虽然JS运行在浏览器中是单线程的，但是浏览器是事件驱动的（Event driven），浏览器中很多行为是异步（Asynchronized）的，会创建事件并放入执行队列中。浏览器中很多异步行为都是由浏览器新开一个线程去完成，一个浏览器至少实现三个常驻线程： JS引擎线程 GUI渲染线程 事件触发线程 2.非阻塞​ 通过 event loop 实现。 JS引擎​ JS引擎是一个专门处理JavaScript脚本的虚拟机，一般会附带在网页浏览器中，比如最出名的就是Chrome浏览器的V8引擎，如下图所示，JS引擎主要有两个组件构成： 堆-内存分配发生的地方 栈-函数调用时会形成一个个栈帧 执行栈​ 每一个函数执行的时候，都会生成新的execution context（执行上下文），执行上下文会包含一些当前函数的参数、局部变量之类的信息，它会被推入栈中， running execution context（正在执行的上下文）始终处于栈的顶部。当函数执行完后，它的执行上下文会从栈弹出。 event loop(事件循环) Event Loop是一个程序结构，用于等待和发送消息和事件 简单说，就是在程序中设置两个线程：一个负责程序本身的运行，称为主线程；另一个负责主线程与其他进程(主要是各种I/O操作)的通信，被称为Event Loop线程(消息线程) 事件循环与任务队列事件循环可以简单描述为： 函数入栈，当Stack中执行到异步任务的时候，就将他丢给WebAPIs,接着执行同步任务,直到Stack为空; 在此期间WebAPIs完成这个事件，把回调函数放入CallbackQueue中等待; 当执行栈为空时，Event Loop把Callback Queue中的一个任务放入Stack中,回到第1步。 Event Loop是由javascript宿主环境（像浏览器）来实现的; WebAPIs是由C++实现的浏览器创建的线程，处理诸如DOM事件、http请求、定时器等异步事件; JavaScript 的并发模型基于”事件循环”; Callback Queue(Event Queue 或者 Message Queue) 任务队列,存放异步任务的回调函数 执行栈: 同步代码的执行，按照顺序添加到执行栈中 事件队列: 异步代码的执行，遇到异步事件不会等待它返回结果，而是将这个事件挂起，继续执行执行栈中的其他任务。当异步事件返回结果，将它放到事件队列中，被放入事件队列不会立刻执行起回调，而是等待当前执行栈中所有任务都执行完毕，主线程空闲状态，主线程会去查找事件队列中是否有任务，如果有，则取出排在第一位的事件，并把这个事件对应的回调放到执行栈中，然后执行其中的同步代码。 简单用下图进行总结： 宏任务和微任务1.为什么要引入微任务，只有一种任务类型不行吗？​ 页面渲染事件，各种IO的完成事件等随时被添加到任务队列中，一直会保持先进先出的原则执行，我们不能准确低控制这些事被添加到任务队列中的位置。但是这个时候突然有高优先级的任务需要尽快执行，那么一种任务类型就不合适了，所以引入了微任务队列。 不同的异步任务分为：宏任务和微任务 宏任务： script(整体代码) setTimeout() setInterval() postMessage I/O UI交互事件 微任务： new Promise().then(回调) MutationObserver(html5 新特性) 2.运行机制 异步任务的返回结果会被放到一个任务队列中，根据异步事件的类型，这个事件实际上会被放到对应的宏任务和微任务队列中去。 在当前执行栈为空时，主线程会查看微任务队列是否有事件存在 存在，依次执行队列中的事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的事件，把当前的回调加到当前执行栈。 如果不存在，那么再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈； 当前执行栈执行完毕后时会立刻处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。 在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下： 执行一个宏任务（栈中没有就从事件队列中获取） 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取） 简单总结一下执行的顺序：执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环。 1234567891011121314console.log(&#x27;start&#x27;)setTimeout(function() &#123; console.log(&#x27;setTimeout&#x27;)&#125;, 0)Promise.resolve().then(function() &#123; console.log(&#x27;promise1&#x27;)&#125;).then(function() &#123; console.log(&#x27;promise2&#x27;)&#125;)console.log(&#x27;end&#x27;)","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"JavaScript","slug":"前端学习栈/JavaScript","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/JavaScript/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://mgy1021.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://mgy1021.github.io/tags/JavaScript/"},{"name":"事件轮询","slug":"事件轮询","permalink":"https://mgy1021.github.io/tags/%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2/"}]},{"title":"一个nodeJs的自动重启工具nodemon","slug":"一个nodeJs的自动重启工具nodemon","date":"2021-09-07T01:34:36.000Z","updated":"2021-09-07T14:37:24.176Z","comments":true,"path":"2021/09/07/一个nodeJs的自动重启工具nodemon/","link":"","permalink":"https://mgy1021.github.io/2021/09/07/%E4%B8%80%E4%B8%AAnodeJs%E7%9A%84%E8%87%AA%E5%8A%A8%E9%87%8D%E5%90%AF%E5%B7%A5%E5%85%B7nodemon/","excerpt":"","text":"nodemon模块node自动重启工具,监听代码文件的变化，当代码改变之后，自动启动。 全局安装1cnpm install -g nodemon 启动项目1nodemon xx.js","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"NodeJs","slug":"前端学习栈/NodeJs","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://mgy1021.github.io/tags/NodeJs/"},{"name":"nodemon","slug":"nodemon","permalink":"https://mgy1021.github.io/tags/nodemon/"}]},{"title":"nodeJs中的Mysql模块的使用","slug":"nodeJs中的Mysql模块的使用","date":"2021-09-07T01:33:54.000Z","updated":"2021-09-12T03:19:29.029Z","comments":true,"path":"2021/09/07/nodeJs中的Mysql模块的使用/","link":"","permalink":"https://mgy1021.github.io/2021/09/07/nodeJs%E4%B8%AD%E7%9A%84Mysql%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"在nodeJS中，使用mysql模块连接数据库,使用方式如下： 12345678910111213141516171819202122const mysql = require(&quot;mysql&quot;)// 1.创建连接对象let conn = mysql.createConnection(&#123; // 主机 host: &quot;8.133.167.153&quot;, // 数据库用户名 user: &quot;root&quot;, // 数据库密码 password: &quot;password&quot;, // 连接数据库名称 database: &quot;test1&quot;&#125;);// 2.发起连接conn.connect();// 3.执行sql语句，处理结果let sql = &#x27;select * from s_student&#x27;;conn.query(sql, (error, result) =&gt; &#123; if (error) throw error; console.log(result);&#125;)// 4.关闭连接conn.end(); express+mysql搭建的简单后台12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * @Description: * @Author: Mogy * @Date: 2021-09-03 16:51:03 * @LastEditors: Mogy * @LastEditTime: 2021-09-06 15:06:28 */const express = require(&quot;express&quot;)const mysql = require(&quot;mysql&quot;)const app = express();app.get(&quot;/findAll&quot;, (req, res) =&gt; &#123; // 获取所有的学生信息，并响应 // 1.创建连接对象 let conn = mysql.createConnection(&#123; host: &quot;8.133.167.153&quot;, user: &quot;root&quot;, password: &quot;password&quot;, database: &quot;test1&quot; &#125;) // 2.发起连接 conn.connect() // 3.执行sql语句 conn.query(&quot;select * from s_student&quot;, (error, result) =&gt; &#123; if (error) throw error; res.send(JSON.stringify(result)); conn.end() &#125;)&#125;)app.get(&quot;/deleteById&quot;, (req, res) =&gt; &#123; // 删除学生 let id = req.query.id // 1.创建连接对象 let conn = mysql.createConnection(&#123; host: &quot;8.133.167.153&quot;, user: &quot;root&quot;, password: &quot;password&quot;, database: &quot;test1&quot; &#125;) // 2.发起连接 conn.connect() // 3.执行sql语句 conn.query(`delete from s_student where id=$&#123;id&#125;`, (error, result) =&gt; &#123; if (error) throw error; console.log(result); res.send(&quot;删除成功&quot;); conn.end() &#125;)&#125;)app.listen(3000, () =&gt; &#123; console.log(&quot;3000端口已启动&quot;);&#125;) 使用连接池Pooling connections连接数据库为了避免每一次与数据库交互都要创建连接对象，我们可以把连接对象放到连接池中进行管理。当需要与数据库进行交互时，调用连接池中的连接对象进行交互即可，无需再重新创建连接对象。注意：连接池中的连接对象是可限定数量的。 一、连接池的使用1. 创建连接对象12345678// 创建连接池对象var pool = mysql.createPool(&#123; connectionLimit:10, host:&quot;example.org&quot;, user:&quot;bob&quot;, password:&quot;secert&quot;, database:&quot;my_db&quot;&#125;) 2. 使用连接池与数据库交互12345678910111213141516171819const mysql = require(&quot;mysql&quot;)// 1.创建连接池对象let pool = mysql.createPool(&#123; // 在连接池里最多有10个连接对象 connectionLimit: 10, host:&quot;example.org&quot;, user:&quot;bob&quot;, password:&quot;secert&quot;, database:&quot;my_db&quot;&#125;)// 2.使用连接池对象执行sql语句，处理结果pool.query(&quot;select * from s_student&quot;, (error, result) =&gt; &#123; if (error) throw error; console.log(result); // 3.关闭连接池 pool.end()&#125;) 二、连接池与连接对象结合使用1234567891011121314151617181920212223const mysql = require(&quot;mysql&quot;)// 1.创建连接池对象let pool = mysql.createPool(&#123; connectionLimit: 10, host: &quot;8.133.167.153&quot;, user: &quot;root&quot;, password: &quot;password&quot;, database: &quot;test1&quot;&#125;)// 2.获取连接对象pool.getConnection((err, conn) =&gt; &#123; // 如果不出错，conn就是连接对象 if (err) throw err; // 3.使用连接对象执行sql语句，并处理结果 conn.query(&quot;select * from s_student&quot;, (error, result) =&gt; &#123; if (error) throw error; console.log(result); // 4.释放连接对象 conn.release(); // 5.关闭连接池(一般不需要关闭连接池) // pool.end() &#125;)&#125;) sql注入在不使用sql注入之前，查询某一个人的信息需要拼接一个变量 1let sql = `select * from s_student where id=$&#123;id&#125;` 使用sql注入：query方法的第二个参数是一个数据，用来接收sql注入的数据。sql注入依赖问号，数组内元素的顺序与sql中问号的顺序一一对应 使用sql注入查询某一记录123456789101112131415// 2.获取连接对象pool.getConnection((err, conn) =&gt; &#123; // 如果不出错，conn就是连接对象 if (err) throw err; let sql = &quot;select * from s_student where id=?&quot; // 3.使用连接对象执行sql语句，并处理结果 conn.query(sql, [1], (error, result) =&gt; &#123; if (error) throw error; console.log(result); // 4.释放连接对象 conn.release(); // 5.关闭连接池(一般不需要关闭连接池) // pool.end() &#125;)&#125;) 使用sql注入插入一条记录123456789101112131415// 2.获取连接对象pool.getConnection((err, conn) =&gt; &#123; // 如果不出错，conn就是连接对象 if (err) throw err; let sql = &quot;insert into s_student(id,name,gender,birth) values(?,?,?,?) &quot; // 3.使用连接对象执行sql语句，并处理结果 conn.query(sql, [null, &quot;lisi&quot;, &quot;男&quot;, &quot;2020-5-08&quot;], (error, result) =&gt; &#123; if (error) throw error; console.log(result); // 4.释放连接对象 conn.release(); // 5.关闭连接池(一般不需要关闭连接池) // pool.end() &#125;)&#125;) 使用sql注入更新一条记录1234567891011121314pool.getConnection((err, conn) =&gt; &#123; // 如果不出错，conn就是连接对象 if (err) throw err; let sql = &quot;update s_student set name=?,gender=? where id=?&quot; // 3.使用连接对象执行sql语句，并处理结果 conn.query(sql, [&quot;lisa&quot;, &quot;女&quot;, 7], (error, result) =&gt; &#123; if (error) throw error; console.log(result); // 4.释放连接对象 conn.release(); // 5.关闭连接池(一般不需要关闭连接池) pool.end() &#125;)&#125;) 使用sql注入删除一条记录123456789101112131415// 2.获取连接对象pool.getConnection((err, conn) =&gt; &#123; // 如果不出错，conn就是连接对象 if (err) throw err; let sql = &quot;delete from s_student where id=?&quot; // 3.使用连接对象执行sql语句，并处理结果 conn.query(sql, [6], (error, result) =&gt; &#123; if (error) throw error; console.log(result); // 4.释放连接对象 conn.release(); // 5.关闭连接池(一般不需要关闭连接池) pool.end() &#125;)&#125;) 批量删除不能用sql注入，只能用字符串拼接12345678910111213141516// 2.获取连接对象pool.getConnection((err, conn) =&gt; &#123; // 如果不出错，conn就是连接对象 if (err) throw err; let str = &quot;9,10,11&quot; let sql = `delete from s_student where id in ($&#123;str&#125;)` // 3.使用连接对象执行sql语句，并处理结果 conn.query(sql, (error, result) =&gt; &#123; if (error) throw error; console.log(result); // 4.释放连接对象 conn.release(); // 5.关闭连接池(一般不需要关闭连接池) pool.end() &#125;)&#125;) 总结使用mysql模块的方式： 可以单纯使用连接对象执行sql 也可以单纯使用连接池对象执行sql 还可以使用连接池+连接对象执行sql","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"NodeJs","slug":"前端学习栈/NodeJs","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://mgy1021.github.io/tags/NodeJs/"},{"name":"Mysql","slug":"Mysql","permalink":"https://mgy1021.github.io/tags/Mysql/"}]},{"title":"一个基于nodeJs的express服务器框架","slug":"一个基于nodeJs的express服务器框架","date":"2021-09-07T01:33:13.000Z","updated":"2021-10-28T05:55:02.380Z","comments":true,"path":"2021/09/07/一个基于nodeJs的express服务器框架/","link":"","permalink":"https://mgy1021.github.io/2021/09/07/%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8EnodeJs%E7%9A%84express%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/","excerpt":"","text":"Express应用程序生成器Express是一个基于Node.js平台、快速、开放、极简的Web开发框架 通过该应用的生成器工具express-generator可以快速创建一个应用的框架。类似前端的脚手架。 一、安装1.全局安装1npm install -g express-generator 二、使用1express 1.创建项目1234567891011121314// 引入express模块const express = require(&quot;express&quot;)// 创建express项目const app = express()// 端口号port = 3000app.get(&quot;/&quot;,(req,res)=&gt;&#123; res.send(&quot;Hello World!&quot;)&#125;)// 监听端口，启动express服务器app.listen(port,()=&gt;&#123; console.log(`Example app listening at http://localhost:$&#123;port&#125;`)&#125;)","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"NodeJs","slug":"前端学习栈/NodeJs","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://mgy1021.github.io/tags/NodeJs/"}]},{"title":"nodeJ中的Buffer缓冲器","slug":"nodeJ中的Buffer缓冲器","date":"2021-09-07T01:32:01.000Z","updated":"2021-09-07T14:34:25.379Z","comments":true,"path":"2021/09/07/nodeJ中的Buffer缓冲器/","link":"","permalink":"https://mgy1021.github.io/2021/09/07/nodeJ%E4%B8%AD%E7%9A%84Buffer%E7%BC%93%E5%86%B2%E5%99%A8/","excerpt":"","text":"Buffer缓冲器Buffer类被引入作为Node.js API的一部分，使其可以在TCP流或文件系统操作等场景中处理二进制数据流。可以将Buffer理解为输送二进制数据流的缓存。 Buffer类在全局作用域中，无需导入","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"NodeJs","slug":"前端学习栈/NodeJs","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://mgy1021.github.io/tags/NodeJs/"}]},{"title":"nodeJ中的s文件系统","slug":"nodeJ中的s文件系统","date":"2021-09-07T01:31:39.000Z","updated":"2021-09-07T14:34:18.799Z","comments":true,"path":"2021/09/07/nodeJ中的s文件系统/","link":"","permalink":"https://mgy1021.github.io/2021/09/07/nodeJ%E4%B8%AD%E7%9A%84s%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"使用Node.js读取文件在Nodejs中读取文件最简单的方法是使用fs.readFile()方法，参数：文件路径，字符编码，回调函数。 12345678// 读取文件fs.readFile(&#x27;./1-url.js&#x27;, &#x27;utf8&#x27;, (err, data) =&gt; &#123; if (err) &#123; console.log(err); return &#125; console.log(data);&#125;) 同步版本fs.readFileSync() 使用Node.js写入文件写入文件最简单的方法是使用fs.writeFile()方法,参数：(写入文件，写入内容，回调函数) 12345678// 写入文件fs.writeFile(&quot;./hello.txt&quot;, &quot;hello123&quot;, err =&gt; &#123; if (err) &#123; console.log(err); return &#125; console.log(&quot;写入成功!&quot;);&#125;) 同步版本fs.writeFileSync() 同步读写文件1234567// 同步读写操作try &#123; let data = fs.readFileSync(&quot;./1-url.js&quot;, &quot;utf8&quot;); fs.writeFileSync(&quot;./1-url2.js&quot;, data)&#125; catch (error) &#123; console.log(error);&#125;","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"NodeJs","slug":"前端学习栈/NodeJs","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://mgy1021.github.io/tags/NodeJs/"}]},{"title":"nodeJs中的进程","slug":"nodeJs中的进程","date":"2021-09-07T01:31:22.000Z","updated":"2021-09-07T14:37:03.072Z","comments":true,"path":"2021/09/07/nodeJs中的进程/","link":"","permalink":"https://mgy1021.github.io/2021/09/07/nodeJs%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B/","excerpt":"","text":"process(进程)process对象是一个全局变量，提供了有关当前Node.js进程的信息并对其进行控制。作为全局变量，它始终可供Node.js应用程序使用，无需使用require()导入。 12345678910process.env.NODE_ENV = &quot;development&quot;process.env.BaseURL = &quot;127.0.0.1:8888&quot;console.log(process.env.NODE_ENV);// console.log(process);// 环境对象console.log(process.env);// 参数数组console.log(process.argv);// 关闭进程的方法// process.exit(1); 处理命令行参数： 123const minimist = require(&quot;minimist&quot;);// 处理命令行的参数console.log(minimist(process.argv.slice(2)));","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"NodeJs","slug":"前端学习栈/NodeJs","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://mgy1021.github.io/tags/NodeJs/"},{"name":"进程","slug":"进程","permalink":"https://mgy1021.github.io/tags/%E8%BF%9B%E7%A8%8B/"}]},{"title":"nodeJs搭建简单Http服务器","slug":"nodeJs搭建简单Http服务器","date":"2021-09-07T01:30:54.000Z","updated":"2021-09-07T14:36:20.602Z","comments":true,"path":"2021/09/07/nodeJs搭建简单Http服务器/","link":"","permalink":"https://mgy1021.github.io/2021/09/07/nodeJs%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95Http%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"Http服务器这是一个简单的HTTP web服务器 1.创建服务器对象​ 浏览器每发一次请求，都会运行该函数。 req是请求对象，通过它可以拿到请求的方式、路径、参数,res是响应对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 创建服务器对象let server = http.createServer((req, res) =&gt; &#123; // 设置响应头部的字符编码 res.setHeader(&quot;Content-Type&quot;, &quot;text/plain;charset=utf-8&quot;) // 浏览器每发一次请求，都会运行该函数 // 获取请求方式，获取请求路径，获取请求参数 console.log(req.method); console.log(req.url); // 获取请求路径 let pathname = url.parse(req.url).pathname // 获取get请求参数 // let query = url.parse(req.url).query // 获取post请求的参数 // let params = &quot;&quot;; // 请求发送请求体里的数据的时候触发data事件处理程序 // req.on(&quot;data&quot;, (chunk) =&gt; &#123; // // chunk是Buffer对象,存放一段一段的数据 // params += chunk // &#125;) // end事件监听请求数据发送完毕 // req.on(&quot;end&quot;, () =&gt; &#123; // console.log(params); // &#125;) // console.log(pathname); // console.log(query); // 不同接口路径返回不同数据 if (pathname === &quot;/user/findAll&quot;) &#123; res.end(&#x27;user的findAll&#x27;); &#125; else if (pathname === &quot;/user/deleteById&quot;) &#123; res.end(&#x27;user的deleteById&#x27;); &#125; // 编写响应体的内容 // res.write(&quot;123&quot;); // 结束响应 // res.end();&#125;) 2.启动服务器1234// 启动服务器server.listen(3000, () =&gt; &#123; console.log(&quot;3000端口启动&quot;);&#125;)","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"NodeJs","slug":"前端学习栈/NodeJs","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://mgy1021.github.io/tags/NodeJs/"},{"name":"Http服务器","slug":"Http服务器","permalink":"https://mgy1021.github.io/tags/Http%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"git","slug":"git","date":"2021-08-30T16:34:30.000Z","updated":"2021-09-06T16:15:09.914Z","comments":true,"path":"2021/08/31/git/","link":"","permalink":"https://mgy1021.github.io/2021/08/31/git/","excerpt":"","text":"初始化本地仓库 git init 更新代码 git pull origin master 提交代码 git add . 将需要提交的所有文件添加到缓存区 git commit -m &#39;提交注释&#39; 将缓存区的内容提交到本地仓库里 git remote add origin 仓库地址 将本地仓库与远程仓库绑定 git push origin master 将本地仓库需要提交的文件推送到远程仓库 解绑仓库 git remote remove 仓库名称 查看与本地仓库绑定的远程仓库 git remote -v","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"git","slug":"前端学习栈/git","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://mgy1021.github.io/tags/Git/"}]},{"title":"ES6","slug":"ES6","date":"2021-08-30T16:33:11.000Z","updated":"2021-09-12T03:03:25.227Z","comments":true,"path":"2021/08/31/ES6/","link":"","permalink":"https://mgy1021.github.io/2021/08/31/ES6/","excerpt":"","text":"1. 为什么要学习ES6 ES的本版变动内容最多，具有里程碑意义 ES6加入许多新的语法特性，编程实现更简单、高效 ES6是前端发展趋势，就业必备技能（在三大框架中大量使用了ES6的语法） 2. ES6的新语法1. let声明变量 变量不能重复声明 块级作用域(变量只在代码块里面有效) 不存在变量提升 不影响作用域链 2. const声明常量 常量的值不能修改 声明时必须赋值 块级作用域 对于数组或者对象进行修改，不会报错 3. 解构赋值 ES6允许按照一定模型从数组或者对象中提取值，对变量进行赋值，这被称为解构赋值。 数组解构 1234567const F4 = [&quot;小沈阳&quot;,&quot;刘能&quot;,&quot;赵四&quot;,&quot;宋小宝&quot;]let [xiao,liu,zhao,song] = F4console.log(xiao); // 小沈阳console.log(liu); // 刘能console.log(xiao); // 赵四console.log(song); // 宋小宝 对象解构 12345678910111213const zhao = &#123; name:&#x27;赵本山&#x27;, age:&quot;不详&quot;, xiaopin:function()&#123; console.log(&quot;我可以演小品&quot;); &#125;&#125;let &#123;name,age,xiaopin&#125; = zhao;console.log(name); //赵本山console.log(age); //不详console.log(xiaopin); //xiaopin方法 4. 模板字符串 ES6引入新的声明字符串的方式 1let str = `我是一个模板字符串哦` 特性： 内容中可以直接出现换行符 变量拼接 let lovest = &#39;魏翔&#39; 1let out = `$&#123;lovest&#125;是我心目中最搞笑的演员` 5. 简化对象 ES6允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。 123456789101112let name = &quot;Mogy&quot;;let change = function()&#123; console.log(&quot;我们可以改变你&quot;)&#125;const school = &#123; name, change, improve()&#123; console.log(&quot;我们可以提升你的技能&quot;) &#125;&#125; 6.箭头函数 特性 this是静态的，this始终是指向函数声明时所在作用域下的this的值。 不能作为构造实例化对象 不能使用arguments变量 箭头函数的简写 省略小括号，当形参有且只有一个时可省略 省略大括号，当代码体中的语句只有一句时可以省略 let pow = n =&gt; n*n 使用场景 箭头函数适合与this无关的回调，定时器，数组的方法回调 箭头函数不适合与this有关的回调，事件回调，对象的方法 7. ES6允许给函数参数赋值初始值 形参初始值（具有默认值的参数，一般位置要靠后） 12345function add(a,b,c=10)&#123; return a+b+c&#125;let result = add(1,2,3) // 6let result = add(1,2) // 13 与解构赋值结合使用 12345678910111213141516171819202122function connect(&#123;host = 127.0.0.1,username,password,port&#125;)&#123; console.log(host); console.log(username); console.log(password); console.log(port);&#125;//传host参数时输出connect(&#123; host:&#x27;baidu.com&#x27;, //输出baidu.com username:&#x27;root&#x27;, //输出root password:&#x27;root&#x27;, //输出root port:3306 //输出3306&#125;)//不host参数时输出默认值connect(&#123; //host输出默认值127.0.0.1 username:&#x27;root&#x27;, //输出root password:&#x27;root&#x27;, //输出root port:3306 //输出3306&#125;) 8. rest参数 ES6引入reset参数，用于获取函数的实参，用来代替arguments 12345function date(...args)&#123; console.log(args);&#125;date(&#x27;阿娇&#x27;,&#x27;柏芝&#x27;,&#x27;思慧&#x27;); //数组 可以使用filter some every map等数组方法 reset参数必须要放到参数最后 9. 扩展运算符... 扩展运算符能将数组转换为逗号分隔的参数列表。 1234567const tfboys = [&quot;易烊千玺&quot;,&quot;王源&quot;,&quot;王俊凯&quot;];//声明一个函数function chunwan()&#123; console.log(arguments)&#125;chunwan(...tfboys) // 相当于chunwan(&quot;易烊千玺&quot;,&quot;王源&quot;,&quot;王俊凯&quot;)// 数组的克隆const sanzhihua = [&#x27;E&#x27;,&#x27;G&#x27;,&#x27;M&#x27;];const sanyecao = [...sanzhihua] // [&#x27;E&#x27;,&#x27;G&#x27;,&#x27;M&#x27;] 10. Symbol基本使用 ES6引入了一种新的数据类型Symbol，表示独一无二的值。它是JS语言的第七种数据类型，是一种类似于字符串的数据类型。 Symbol的特点 Symbol的值是唯一的，用来解决命名冲突的问题 Symbol的值不能与其他数据进行运算 Symbol定义的对象属性不能使用for...in循环遍历，但是可以使用Reflect.ownKeys来获取对象的所有键名 1//创建一个Symbollet s = Symbol();console.log(s,typeof s); // Symbol() &quot;Symbol&quot;let s2 = Symbol(&quot;注释&quot;);let s3 = Symbol(&quot;注释&quot;);console.log(s2 == s3) // false// Symbol.for 创建let s4 = Symbol.for(&#x27;Mogy&#x27;);let s5 = Symbol.for(&#x27;Mogy&#x27;);console.log(s4 == s5) // true Symbol的使用场景 给对象添加属性或者方法，表示独一无二的 1234567891011121314151617181920let game = &#123; name: &#x27;俄罗斯方块&#x27;, up() &#123; console.log(&quot;向上&quot;); &#125;, down() &#123; console.log(&quot;向下&quot;); &#125;&#125;let methods = &#123; up: Symbol(), down: Symbol(),&#125;game[methods.up] = function () &#123; console.log(&quot;我可以改变形状&quot;);&#125;game[methods.down] = function () &#123; console.log(&quot;我可以快速下降&quot;);&#125;console.log(game); 11. 迭代器​ 迭代器是一种接口，为各种不同的数据类型提供统一的访问机制。任何数据结构只要部署了Iterator接口(指的是对象里的一个属性)，就可以完成遍历操作。 原生具备Iterator接口的数据 Array Arguments Set Map String TypedArray NodeList 工作原理 创建一个指针对象，指向当前数据结构的起始位置 第一次调用对象的next方法，指针自动指向数据结构的第一个成员 接下来不断调用next方法，指针一直往后移动，直到指向最后一个成员 12. 生成器​ 生成器其实就是一个特殊的函数 123456789101112function* gen() &#123; console.log(111); yield 1 console.log(222); yield 2 console.log(333); yield 3&#125;let Iterator = gen() // 返回一个迭代器对象Iterator.next() // 111Iterator.next() // 222Iterator.next() // 333 13. Set集合​ ES6提供了新的数据结构Set集合，它是一个对象，类似于数组，但是成员是唯一的。 1234567891011121314//声明一个 setlet s = new Set();let s2 = new Set([&quot;好事&quot;, &quot;喜事&quot;, &quot;坏事&quot;, &quot;丑事&quot;, &quot;好事&quot;]);console.log(typeof s) // Object// 获取元素的个数console.log(s2.size) // 4// 添加元素s2.add(&quot;悲事&quot;)// 删除元素s2.delete(&quot;好事&quot;)// 检测s2.has(&quot;好事&quot;)// 清空s2.clear() 14.类15.数值扩展 Number.EPSILON Number.EPSILON是JavaScript表示的最小精度 123456789console.log(0.1 + 0.2 === 0.3) // falsefunction equal(a, b) &#123; if (Math.abs(a - b) &lt; Number.EPSILON) &#123; return true; &#125; else &#123; return false; &#125;&#125;console.log(equal(0.1 + 0.2, 0.3)) // true Number.isFinite 检查一个数值是否为有限数 Number.isNaN 检测一个数值是否为NaN Number.parseInt 字符串转整数 Number.isInteger 判断一个数是否为整数 Math.trunc 将数字的小数部分抹掉 Math.sign 判断一个数是整数、负数还是零 16.对象方法的扩展 Object.is 判断两个值是否完全相等 Object.assign 对象合并 Object.setPrototypeOf Object.getPrototypeOf 设置原型对象 17.模块化​ 模块化是指将一个大的程序文件，拆分成许多小的文件，然后将小文件组合起来。 模块化开发的好处 防止命名冲突 代码复用 高维护性 模块化规范 CommonJS =&gt; NodeJS、Browserify AMD =&gt; requireJS CMD =&gt; seaJS ES6模块化语法 export命令用于规定模块的对外接口 import命令用于输入其他模块提供的功能 导出的方式： export let a = 2 export &#123;a,method&#125; export default &#123;对象&#125; 引入的方式： 通用方式 import * as m1 from &quot;...&quot; 解构赋值形式 import &#123;school,teach&#125; from &quot;...&quot; import &#123;default as m3&#125; from &quot;...&quot; 简便形式(针对默认暴露) import m3 from &quot;...&quot; babel 1npx babel 文件 -d 文件夹 --presets=babel-preset-env 模块化的差异 ES6模块与CommonJS模块化的差异： CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用 ES6模块加载的不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。 ES6模块输出的是值的引用 CommonJS模块是运行时加载，ES6模块时编译时输出接口 加载的是一个对象,即module.exports属性，该对象只有在脚本运行完才能完成。 3. ES7的新特性 Array.prototype.includes 用来检测数组中是否包含某个元素，返回布尔类型值 **幂运算 相当于Math.pow(), 2**3 ==&gt; Math.pow(2,3) 4.ES8的新特性4.1 async和await​ 异步编程的解决方案，async和await两种语法结合可以让异步代码像同步代码一样编写 4.1.1 async函数 async函数的返回值为promise对象 promise对象的结果由async函数执行的返回值决定 4.1.2 await表达式 await必须写在async函数中 await右侧的表达式一般为promise对象 await返回的是promise成功的值 await的promise失败了，就会抛出异常，需要通过try…catch捕获处理","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"ES6","slug":"前端学习栈/ES6","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://mgy1021.github.io/tags/ES6/"}],"author":"Mogy"},{"title":"Ajax","slug":"Ajax","date":"2021-08-30T16:30:29.000Z","updated":"2021-09-07T13:12:58.498Z","comments":true,"path":"2021/08/31/Ajax/","link":"","permalink":"https://mgy1021.github.io/2021/08/31/Ajax/","excerpt":"","text":"AJAX的特点1.AJAX的优点 （1）可以无需刷新页面与服务器进行通信 （2）允许你根据用户事件来更新部分网页内容 2.AJAX的缺点 （1）没有浏览历史，不能回退 （2）存在跨域问题（同源） （3）SEO不友好 AJAX的使用1.AJAX的基本操作 12345678910111213141516&lt;!-- 1.创建对象 --&gt;const xhr = new XMLHttpRequest()&lt;!-- 2.初始化 设置请求方式和URL --&gt;xhr.open(&#x27;GET&#x27;，URL)&lt;!-- 3.发送 --&gt;xhr.send()&lt;!-- 4.绑定事件 --&gt;xhr.onreadyStateChange = function () &#123; &lt;!-- 判断（服务器是否返回全部结果） --&gt; if(xhr.readyState === 4)&#123; &lt;!-- 判断（响应是否成功） --&gt; if(xhr.status &gt;= 200&amp;&amp;xhr.status &lt; 300)&#123; console.log(xhr.response) &#125; &#125;&#125; 2.传参 （1）GET请求 在URL后面拼接，例如:http://127.0.0.1:8000/server?username=Mogy&amp;age=12 （2）POST请求 在send方法中传参，例如：xhr.send(‘username=Mogy&amp;age=12’) 3.超时请求和网络异常处理 （1）超时请求 xhr.timeout = 2000 （2）网络异常处理 123xhr.onerror = function () &#123; alert(&quot;你的网络似乎出了问题!!!&quot;) &#125; 4.手动取消请求 （1）xhr.abort() Jquery发送ajax1.发GET $.get(url,data,function()&#123;&#125;,&#39;json&#39;) 2.发POST $.post(url,data,function()&#123;&#125;) 3.通用方法 12345678910111213141516$.ajax(&#123; &lt;!-- 请求路径 --&gt; url:&#x27;&#x27;, &lt;!-- 请求方式 --&gt; type:&#x27;&#x27;, &lt;!-- 参数 --&gt; data:&#123;&#125;, &lt;!-- 设置响应体的数据类型 --&gt; datatype:&#x27;json&#x27; &lt;!-- 成功回调 --&gt; success()&#123;&#125;, &lt;!-- 错误回调 --&gt; error()&#123;&#125;, &lt;!-- 设置请求超时 --&gt; timeout:2000,&#125;) axios发ajax1.发GET请求 axios.get(url,config).then().catch() 2.发POST请求 axios.post(url,data,config),then().catch() 3.通用方法 123456789101112axios(&#123; &lt;!-- 请求路径 --&gt; url:&#x27;&#x27;, &lt;!-- 请求方式 --&gt; method:&#x27;&#x27;, &lt;!-- 设置请求头 --&gt; headers:&#123;&#125;, &lt;!-- 请求体 --&gt; data:&#123;&#125; &lt;!-- url传参 --&gt; params:&#123;&#125;&#125;) ajax同源策略 1.同源策略是浏览器的一种安全策略 2.同源：协议、域名、端口号 必须完全相同 3.违背同源策略就是跨域 解决跨域： Jsonp Cros 浏览器解决跨域： https://blog.csdn.net/qq_37338983/article/details/78606064 火狐浏览器下载CORS-EVERYWHERE插件即可解决跨域问题 HTTP协议1.HTTP简介 超文本传输协议，协议详细规定了浏览器和万维网服务器之间相互通信的规则 2.内容 1.请求报文 重点是格式和参数： 1234行 POST /s?ie=utf-8 HTTP/1.1头 空行体 2.响应报文 1234行 HTTP/1.1 200 OK头空行体","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"Ajax","slug":"前端学习栈/Ajax","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/Ajax/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://mgy1021.github.io/tags/Ajax/"}]},{"title":"Webpack","slug":"Webpack","date":"2021-08-20T01:31:05.000Z","updated":"2021-09-08T01:11:06.916Z","comments":true,"path":"2021/08/20/Webpack/","link":"","permalink":"https://mgy1021.github.io/2021/08/20/Webpack/","excerpt":"","text":"Webpack的简介1. 什么是Webpack？Webpac是一种前端资源构建工具，一个静态模块打包器(module bundler)。 在Webpack看来，前端的所有资源文件(js/json/css/img/less/…)都会作为模块处理。它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源(bundle)。 2. Webpack的五个核心概念2.1 Entry​ 入口(entry)指示Webpack以哪个文件为入口起点开始打包，分析构建内部依赖图。 2.2 Output​ 输出(output)指示Webpack打包后的资源bundle输出到哪里去，以及如何命名。 2.3 loader​ Loader让webpack能够处理一些非JavaScript文件(webpack自身只认识JavaScript) 2.4 Plugins​ 插件(Plugins)可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩一直到重新定义环境中的变量等。 2.5 Mode​ 模式(Mode)指示Webpack使用相应模式的配置。 选项 描述 特点 development 会将process.env.NODE_ENV的值设为development。启用NamedChunksPlugin和NamedModulesPlugin. 能够让本地调试运行环境 production 会将process.env.NODE_ENV的值设为production。启用FlagDependencyUsagePlugin等 能够让代码优化上线运行的环境 3. Webpack初体验3.1 运行指令​ 开发环境：webpack ./src/index.js -o ./build/build.js –mode=development ​ webpack会以 ./src/index.js为入口文件开始打包，打包后输出到./build/built.js文件 ​ 整体打包环境是开发环境 ​ 生产环境：webpack ./src/index.js -o ./build/build.js –mode=production ​ webpack会以 ./src/index.js为入口文件开始打包，打包后输出到./build/built.js文件 ​ 整体打包环境是生产环境 3.2 结论 webpack能处理js/json资源,不能处理css/img等其他资源。 生产环境和开发环境将ES6模块化编译成浏览器能识别的模块化。 生产环境比开发环境多一个压缩代码。 4. 打包样式资源webpack.config.js是webpack的配置文件 作用：指示webpack干哪些活（当你运行webpack指令时，会加载里面的配置） 注意：所有构建工具都是基于nodejs平台运行的~模块化默认采用commonJS 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* * @Description: * @Author: Mogy * @Date: 2021-08-19 14:51:29 * @LastEditors: Mogy * @LastEditTime: 2021-08-19 15:34:37 *///resolve用来拼接绝对路径的方法const &#123; resolve &#125; = require(&quot;path&quot;)module.exports = &#123; // webpack配置 entry: &#x27;./src/index.js&#x27;, // 输出 output: &#123; // 输出文件名 filename: &#x27;built.js&#x27;, // 输出的路径 //__dirname nodejs的变量，代表当前文件所在目录的绝对路径 path: resolve(__dirname, &#x27;build&#x27;) &#125;, //loader的配置 module: &#123; rules: [ //详细的loader配置 // 不同文件必须配置不同的loader处理 &#123; //匹配哪些文件 test: /\\.css$/, // 使用哪些loader进行处理 use: [ //use数组中loader执行顺序：从右到左，从上到下。依次执行 //创建style标签，将js中的css样式资源插入进去，添加到head中生效 &#x27;style-loader&#x27;, //将css文件编成commonJS模块加载到js中，里面的内容是样式字符串 &#x27;css-loader&#x27; ] &#125;, &#123; test: /\\.less$/, use: [ &quot;style-loader&quot;, &quot;css-loader&quot;, // 将less文件编译成css文件 &quot;less-loader&quot; ] &#125; ] &#125;, // plugins的配置 plugins: [ //详细plugins的配置 ], // 模式 mode: &#x27;development&#x27;, // mode: &#x27;production&#x27;&#125; 5. Webpack打包html资源123456789101112131415161718192021222324252627282930313233343536373839404142434445/* * @Description: * @Author: Mogy * @Date: 2021-08-19 15:45:13 * @LastEditors: Mogy * @LastEditTime: 2021-08-19 16:00:22 *//* loader: 1. 下载 2. 使用（配置loader） plugins： 1. 下载 2. 引入 3. 使用*/const &#123; resolve &#125; = require(&#x27;path&#x27;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;built.js&#x27;, path: resolve(__dirname, &quot;build&quot;) &#125;, module: &#123; rules: [ // loader的配置 ] &#125;, plugins: [ // plugins的配置 // html-webpack-plugin // 功能：默认会创建一个空的HTML文件，自动引入打包输出的所有资源(JS/CSS) // 需求：需要有结构的HTML文件 new HtmlWebpackPlugin(&#123; // 复制一个HTML文件，并自动引入打包输出的所有资源(JS/CSS) template: &#x27;./src/index.html&#x27; &#125;) ], mode: &quot;development&quot;&#125; 6. Webpack打包图片资源","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"Webpack","slug":"前端学习栈/Webpack","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://mgy1021.github.io/tags/Webpack/"}]}],"categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"CSS","slug":"前端学习栈/CSS","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/CSS/"},{"name":"HTML5","slug":"前端学习栈/HTML5","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/HTML5/"},{"name":"JavaScript","slug":"前端学习栈/JavaScript","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/JavaScript/"},{"name":"浏览器","slug":"前端学习栈/浏览器","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"服务器相关","slug":"服务器相关","permalink":"https://mgy1021.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3/"},{"name":"内网穿透","slug":"服务器相关/内网穿透","permalink":"https://mgy1021.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"name":"NodeJs","slug":"前端学习栈/NodeJs","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/NodeJs/"},{"name":"git","slug":"前端学习栈/git","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/git/"},{"name":"ES6","slug":"前端学习栈/ES6","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/ES6/"},{"name":"Ajax","slug":"前端学习栈/Ajax","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/Ajax/"},{"name":"Webpack","slug":"前端学习栈/Webpack","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/Webpack/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://mgy1021.github.io/tags/CSS/"},{"name":"HTML5","slug":"HTML5","permalink":"https://mgy1021.github.io/tags/HTML5/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://mgy1021.github.io/tags/JavaScript/"},{"name":"浏览器内核","slug":"浏览器内核","permalink":"https://mgy1021.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/"},{"name":"内网穿透","slug":"内网穿透","permalink":"https://mgy1021.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"name":"NodeJs","slug":"NodeJs","permalink":"https://mgy1021.github.io/tags/NodeJs/"},{"name":"apidoc","slug":"apidoc","permalink":"https://mgy1021.github.io/tags/apidoc/"},{"name":"pkg","slug":"pkg","permalink":"https://mgy1021.github.io/tags/pkg/"},{"name":"exe","slug":"exe","permalink":"https://mgy1021.github.io/tags/exe/"},{"name":"重绘回流","slug":"重绘回流","permalink":"https://mgy1021.github.io/tags/%E9%87%8D%E7%BB%98%E5%9B%9E%E6%B5%81/"},{"name":"浏览器渲染原理","slug":"浏览器渲染原理","permalink":"https://mgy1021.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/"},{"name":"Promise","slug":"Promise","permalink":"https://mgy1021.github.io/tags/Promise/"},{"name":"SVG","slug":"SVG","permalink":"https://mgy1021.github.io/tags/SVG/"},{"name":"workers","slug":"workers","permalink":"https://mgy1021.github.io/tags/workers/"},{"name":"多线程","slug":"多线程","permalink":"https://mgy1021.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"防抖与节流","slug":"防抖与节流","permalink":"https://mgy1021.github.io/tags/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"},{"name":"浏览器","slug":"浏览器","permalink":"https://mgy1021.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"事件轮询","slug":"事件轮询","permalink":"https://mgy1021.github.io/tags/%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2/"},{"name":"nodemon","slug":"nodemon","permalink":"https://mgy1021.github.io/tags/nodemon/"},{"name":"Mysql","slug":"Mysql","permalink":"https://mgy1021.github.io/tags/Mysql/"},{"name":"进程","slug":"进程","permalink":"https://mgy1021.github.io/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"Http服务器","slug":"Http服务器","permalink":"https://mgy1021.github.io/tags/Http%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Git","slug":"Git","permalink":"https://mgy1021.github.io/tags/Git/"},{"name":"ES6","slug":"ES6","permalink":"https://mgy1021.github.io/tags/ES6/"},{"name":"Ajax","slug":"Ajax","permalink":"https://mgy1021.github.io/tags/Ajax/"},{"name":"Webpack","slug":"Webpack","permalink":"https://mgy1021.github.io/tags/Webpack/"}]}