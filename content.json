{"meta":{"title":"Mogy的博客","subtitle":"","description":"","author":"Mogy","url":"https://mgy1021.github.io","root":"/"},"pages":[{"title":"所有分类","date":"2021-09-01T01:53:29.629Z","updated":"2021-09-01T01:53:29.457Z","comments":true,"path":"categories/index.html","permalink":"https://mgy1021.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-08-20T05:13:51.000Z","updated":"2021-09-01T02:20:04.645Z","comments":true,"path":"tags/index.html","permalink":"https://mgy1021.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-07T13:34:05.289Z","updated":"2021-09-07T13:34:05.189Z","comments":true,"path":"about/index.html","permalink":"https://mgy1021.github.io/about/index.html","excerpt":"","text":"下面写关于自己的内容"}],"posts":[{"title":"线程机制与事件机制","slug":"线程机制与事件机制","date":"2021-09-08T06:40:05.000Z","updated":"2021-09-08T07:15:44.077Z","comments":true,"path":"2021/09/08/线程机制与事件机制/","link":"","permalink":"https://mgy1021.github.io/2021/09/08/%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/","excerpt":"","text":"进程与线程进程(process)​ 程序的一次执行，它占有了一片独有的内存空间。可以通过Window任务管理器查看进程。 线程(thread)​ 线程是进程内的一个概念，线程是进程内的一个独立执行单元，是程序执行的一个完整流程，是CPU的最小的调度单元。 JS是一门单线程语言,但是使用H5中的Web Workers可以多线程运行。浏览器运行是多线程的 单进程浏览器(firefox,老版IE)，多进程浏览器(chrome,新版IE) 相关知识 应用程序必须运行在某个进程的某个线程上 一个进程中至少有一个运行的线程：主线程，进程启动后自动创建 一个进程中也可以同时运行多个线程，我们会说程序是多线程运行的 一个进程内的数据可以供其中的多个线程直接共享 多个进程之间的数据是不能直接共享的 线程池(thread pool):保存多个线程对象的容器，实现线程对象的反复利用。 浏览器内核什么是浏览器内核？支撑浏览器运行的最核心的程序。不同浏览器可能不一样，内核由很多模块组成。模块有： JS引擎模块：负责js程序的编译与运行 html，css文档解析模块：负责页面文本的解析 DOM/CSS模块：负责dom/css在内存中的相关处理（生成DOM对象树） 布局和渲染模块：负责页面的布局和效果的绘制（内存中的对象） 定时器模块：负责定时器的管理 事件响应模块：负责事件的管理 网络请求模块：负责ajax请求 等等 JS代码分类和执行顺序JS代码分类 同步代码 回调代码 JS引擎执行代码的基本流程 先执行同步代码 设置定时器 绑定监听 发送ajax请求 后面在某个时刻才会执行回调代码 浏览器的事件循环机制JS是单线程的，非阻塞的1.单线程​ JS是单线程的，或者说只有一个主线程，也就是说它只能执行一段代码。所谓的单线程也只是相对于多线程而言。JS的设计初衷就没有考虑这些，针对JS这种不具备并行任务处理的特性，我们称之为“单线程”。 JavaScript的主要用途是与用户互动，以及操作DOM。如果它是多线程的会有很多复杂的问题要处理，比如有两个线程同时操作DOM，一个线程删除了当前的DOM节点，一个线程是要操作当前的DOM阶段，最后以哪个线程的操作为准？为了避免这种，所以JS是单线程的。即使H5提出了web worker标准，它有很多限制，受主线程控制，是主线程的子线程。 虽然JS运行在浏览器中是单线程的，但是浏览器是事件驱动的（Event driven），浏览器中很多行为是异步（Asynchronized）的，会创建事件并放入执行队列中。浏览器中很多异步行为都是由浏览器新开一个线程去完成，一个浏览器至少实现三个常驻线程： JS引擎线程 GUI渲染线程 事件触发线程 2.非阻塞​ 通过 event loop 实现。 JS引擎​ JS引擎是一个专门处理JavaScript脚本的虚拟机，一般会附带在网页浏览器中，比如最出名的就是Chrome浏览器的V8引擎，如下图所示，JS引擎主要有两个组件构成： 堆-内存分配发生的地方 栈-函数调用时会形成一个个栈帧 执行栈​ 每一个函数执行的时候，都会生成新的execution context（执行上下文），执行上下文会包含一些当前函数的参数、局部变量之类的信息，它会被推入栈中， running execution context（正在执行的上下文）始终处于栈的顶部。当函数执行完后，它的执行上下文会从栈弹出。 event loop(事件循环) Event Loop是一个程序结构，用于等待和发送消息和事件 简单说，就是在程序中设置两个线程：一个负责程序本身的运行，称为主线程；另一个负责主线程与其他进程(主要是各种I/O操作)的通信，被称为Event Loop线程(消息线程) 事件循环与任务队列事件循环可以简单描述为： 函数入栈，当Stack中执行到异步任务的时候，就将他丢给WebAPIs,接着执行同步任务,直到Stack为空; 在此期间WebAPIs完成这个事件，把回调函数放入CallbackQueue中等待; 当执行栈为空时，Event Loop把Callback Queue中的一个任务放入Stack中,回到第1步。 Event Loop是由javascript宿主环境（像浏览器）来实现的; WebAPIs是由C++实现的浏览器创建的线程，处理诸如DOM事件、http请求、定时器等异步事件; JavaScript 的并发模型基于”事件循环”; Callback Queue(Event Queue 或者 Message Queue) 任务队列,存放异步任务的回调函数 执行栈: 同步代码的执行，按照顺序添加到执行栈中 事件队列: 异步代码的执行，遇到异步事件不会等待它返回结果，而是将这个事件挂起，继续执行执行栈中的其他任务。当异步事件返回结果，将它放到事件队列中，被放入事件队列不会立刻执行起回调，而是等待当前执行栈中所有任务都执行完毕，主线程空闲状态，主线程会去查找事件队列中是否有任务，如果有，则取出排在第一位的事件，并把这个事件对应的回调放到执行栈中，然后执行其中的同步代码。 简单用下图进行总结： 宏任务和微任务1.为什么要引入微任务，只有一种任务类型不行吗？​ 页面渲染事件，各种IO的完成事件等随时被添加到任务队列中，一直会保持先进先出的原则执行，我们不能准确低控制这些事被添加到任务队列中的位置。但是这个时候突然有高优先级的任务需要尽快执行，那么一种任务类型就不合适了，所以引入了微任务队列。 不同的异步任务分为：宏任务和微任务 宏任务： script(整体代码) setTimeout() setInterval() postMessage I/O UI交互事件 微任务： new Promise().then(回调) MutationObserver(html5 新特性) 2.运行机制 异步任务的返回结果会被放到一个任务队列中，根据异步事件的类型，这个事件实际上会被放到对应的宏任务和微任务队列中去。 在当前执行栈为空时，主线程会查看微任务队列是否有事件存在 存在，依次执行队列中的事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的事件，把当前的回调加到当前执行栈。 如果不存在，那么再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈； 当前执行栈执行完毕后时会立刻处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。 在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下： 执行一个宏任务（栈中没有就从事件队列中获取） 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取） 简单总结一下执行的顺序：执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环。 1234567891011121314console.log(&#x27;start&#x27;)setTimeout(function() &#123; console.log(&#x27;setTimeout&#x27;)&#125;, 0)Promise.resolve().then(function() &#123; console.log(&#x27;promise1&#x27;)&#125;).then(function() &#123; console.log(&#x27;promise2&#x27;)&#125;)console.log(&#x27;end&#x27;)","categories":[],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://mgy1021.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://mgy1021.github.io/tags/JavaScript/"},{"name":"事件轮询","slug":"事件轮询","permalink":"https://mgy1021.github.io/tags/%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2/"}]},{"title":"一个nodeJs的自动重启工具nodemon","slug":"一个nodeJs的自动重启工具nodemon","date":"2021-09-07T01:34:36.000Z","updated":"2021-09-07T14:37:24.176Z","comments":true,"path":"2021/09/07/一个nodeJs的自动重启工具nodemon/","link":"","permalink":"https://mgy1021.github.io/2021/09/07/%E4%B8%80%E4%B8%AAnodeJs%E7%9A%84%E8%87%AA%E5%8A%A8%E9%87%8D%E5%90%AF%E5%B7%A5%E5%85%B7nodemon/","excerpt":"","text":"nodemon模块node自动重启工具,监听代码文件的变化，当代码改变之后，自动启动。 全局安装1cnpm install -g nodemon 启动项目1nodemon xx.js","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"NodeJs","slug":"前端学习栈/NodeJs","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://mgy1021.github.io/tags/NodeJs/"},{"name":"nodemon","slug":"nodemon","permalink":"https://mgy1021.github.io/tags/nodemon/"}]},{"title":"nodeJs中的Mysql模块的使用","slug":"nodeJs中的Mysql模块的使用","date":"2021-09-07T01:33:54.000Z","updated":"2021-09-07T14:36:40.079Z","comments":true,"path":"2021/09/07/nodeJs中的Mysql模块的使用/","link":"","permalink":"https://mgy1021.github.io/2021/09/07/nodeJs%E4%B8%AD%E7%9A%84Mysql%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"在nodeJS中，使用mysql模块连接数据库,使用方式如下： 12345678910111213141516171819202122const mysql = require(&quot;mysql&quot;)// 1.创建连接对象let conn = mysql.createConnection(&#123; // 主机 host: &quot;8.133.167.153&quot;, // 数据库用户名 user: &quot;root&quot;, // 数据库密码 password: &quot;lq.19990312&quot;, // 连接数据库名称 database: &quot;test1&quot;&#125;);// 2.发起连接conn.connect();// 3.执行sql语句，处理结果let sql = &#x27;select * from s_student&#x27;;conn.query(sql, (error, result) =&gt; &#123; if (error) throw error; console.log(result);&#125;)// 4.关闭连接conn.end(); express+mysql搭建的简单后台12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * @Description: * @Author: Mogy * @Date: 2021-09-03 16:51:03 * @LastEditors: Mogy * @LastEditTime: 2021-09-06 15:06:28 */const express = require(&quot;express&quot;)const mysql = require(&quot;mysql&quot;)const app = express();app.get(&quot;/findAll&quot;, (req, res) =&gt; &#123; // 获取所有的学生信息，并响应 // 1.创建连接对象 let conn = mysql.createConnection(&#123; host: &quot;8.133.167.153&quot;, user: &quot;root&quot;, password: &quot;lq.19990312&quot;, database: &quot;test1&quot; &#125;) // 2.发起连接 conn.connect() // 3.执行sql语句 conn.query(&quot;select * from s_student&quot;, (error, result) =&gt; &#123; if (error) throw error; res.send(JSON.stringify(result)); conn.end() &#125;)&#125;)app.get(&quot;/deleteById&quot;, (req, res) =&gt; &#123; // 删除学生 let id = req.query.id // 1.创建连接对象 let conn = mysql.createConnection(&#123; host: &quot;8.133.167.153&quot;, user: &quot;root&quot;, password: &quot;lq.19990312&quot;, database: &quot;test1&quot; &#125;) // 2.发起连接 conn.connect() // 3.执行sql语句 conn.query(`delete from s_student where id=$&#123;id&#125;`, (error, result) =&gt; &#123; if (error) throw error; console.log(result); res.send(&quot;删除成功&quot;); conn.end() &#125;)&#125;)app.listen(3000, () =&gt; &#123; console.log(&quot;3000端口已启动&quot;);&#125;) 使用连接池Pooling connections连接数据库为了避免每一次与数据库交互都要创建连接对象，我们可以把连接对象放到连接池中进行管理。当需要与数据库进行交互时，调用连接池中的连接对象进行交互即可，无需再重新创建连接对象。注意：连接池中的连接对象是可限定数量的。 一、连接池的使用1. 创建连接对象12345678// 创建连接池对象var pool = mysql.createPool(&#123; connectionLimit:10, host:&quot;example.org&quot;, user:&quot;bob&quot;, password:&quot;secert&quot;, database:&quot;my_db&quot;&#125;) 2. 使用连接池与数据库交互12345678910111213141516171819const mysql = require(&quot;mysql&quot;)// 1.创建连接池对象let pool = mysql.createPool(&#123; // 在连接池里最多有10个连接对象 connectionLimit: 10, host:&quot;example.org&quot;, user:&quot;bob&quot;, password:&quot;secert&quot;, database:&quot;my_db&quot;&#125;)// 2.使用连接池对象执行sql语句，处理结果pool.query(&quot;select * from s_student&quot;, (error, result) =&gt; &#123; if (error) throw error; console.log(result); // 3.关闭连接池 pool.end()&#125;) 二、连接池与连接对象结合使用1234567891011121314151617181920212223const mysql = require(&quot;mysql&quot;)// 1.创建连接池对象let pool = mysql.createPool(&#123; connectionLimit: 10, host: &quot;8.133.167.153&quot;, user: &quot;root&quot;, password: &quot;lq.19990312&quot;, database: &quot;test1&quot;&#125;)// 2.获取连接对象pool.getConnection((err, conn) =&gt; &#123; // 如果不出错，conn就是连接对象 if (err) throw err; // 3.使用连接对象执行sql语句，并处理结果 conn.query(&quot;select * from s_student&quot;, (error, result) =&gt; &#123; if (error) throw error; console.log(result); // 4.释放连接对象 conn.release(); // 5.关闭连接池(一般不需要关闭连接池) // pool.end() &#125;)&#125;) sql注入在不使用sql注入之前，查询某一个人的信息需要拼接一个变量 1let sql = `select * from s_student where id=$&#123;id&#125;` 使用sql注入：query方法的第二个参数是一个数据，用来接收sql注入的数据。sql注入依赖问号，数组内元素的顺序与sql中问号的顺序一一对应 使用sql注入查询某一记录123456789101112131415// 2.获取连接对象pool.getConnection((err, conn) =&gt; &#123; // 如果不出错，conn就是连接对象 if (err) throw err; let sql = &quot;select * from s_student where id=?&quot; // 3.使用连接对象执行sql语句，并处理结果 conn.query(sql, [1], (error, result) =&gt; &#123; if (error) throw error; console.log(result); // 4.释放连接对象 conn.release(); // 5.关闭连接池(一般不需要关闭连接池) // pool.end() &#125;)&#125;) 使用sql注入插入一条记录123456789101112131415// 2.获取连接对象pool.getConnection((err, conn) =&gt; &#123; // 如果不出错，conn就是连接对象 if (err) throw err; let sql = &quot;insert into s_student(id,name,gender,birth) values(?,?,?,?) &quot; // 3.使用连接对象执行sql语句，并处理结果 conn.query(sql, [null, &quot;lisi&quot;, &quot;男&quot;, &quot;2020-5-08&quot;], (error, result) =&gt; &#123; if (error) throw error; console.log(result); // 4.释放连接对象 conn.release(); // 5.关闭连接池(一般不需要关闭连接池) // pool.end() &#125;)&#125;) 使用sql注入更新一条记录1234567891011121314pool.getConnection((err, conn) =&gt; &#123; // 如果不出错，conn就是连接对象 if (err) throw err; let sql = &quot;update s_student set name=?,gender=? where id=?&quot; // 3.使用连接对象执行sql语句，并处理结果 conn.query(sql, [&quot;lisa&quot;, &quot;女&quot;, 7], (error, result) =&gt; &#123; if (error) throw error; console.log(result); // 4.释放连接对象 conn.release(); // 5.关闭连接池(一般不需要关闭连接池) pool.end() &#125;)&#125;) 使用sql注入删除一条记录123456789101112131415// 2.获取连接对象pool.getConnection((err, conn) =&gt; &#123; // 如果不出错，conn就是连接对象 if (err) throw err; let sql = &quot;delete from s_student where id=?&quot; // 3.使用连接对象执行sql语句，并处理结果 conn.query(sql, [6], (error, result) =&gt; &#123; if (error) throw error; console.log(result); // 4.释放连接对象 conn.release(); // 5.关闭连接池(一般不需要关闭连接池) pool.end() &#125;)&#125;) 批量删除不能用sql注入，只能用字符串拼接12345678910111213141516// 2.获取连接对象pool.getConnection((err, conn) =&gt; &#123; // 如果不出错，conn就是连接对象 if (err) throw err; let str = &quot;9,10,11&quot; let sql = `delete from s_student where id in ($&#123;str&#125;)` // 3.使用连接对象执行sql语句，并处理结果 conn.query(sql, (error, result) =&gt; &#123; if (error) throw error; console.log(result); // 4.释放连接对象 conn.release(); // 5.关闭连接池(一般不需要关闭连接池) pool.end() &#125;)&#125;) 总结使用mysql模块的方式： 可以单纯使用连接对象执行sql 也可以单纯使用连接池对象执行sql 还可以使用连接池+连接对象执行sql","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"NodeJs","slug":"前端学习栈/NodeJs","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://mgy1021.github.io/tags/NodeJs/"},{"name":"Mysql","slug":"Mysql","permalink":"https://mgy1021.github.io/tags/Mysql/"}]},{"title":"一个基于nodeJs的express服务器框架","slug":"一个基于nodeJs的express服务器框架","date":"2021-09-07T01:33:13.000Z","updated":"2021-09-07T14:33:55.206Z","comments":true,"path":"2021/09/07/一个基于nodeJs的express服务器框架/","link":"","permalink":"https://mgy1021.github.io/2021/09/07/%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8EnodeJs%E7%9A%84express%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/","excerpt":"","text":"Express应用程序生成器Express是一个基于Node.js平台、快速、开放、极简的Web开发框架 通过该应用的生成器工具express-generator可以快速创建一个应用的框架。类似前端的脚手架。 安装1.全局安装1npm install -g express-generator 使用1.创建项目1234567891011121314// 引入express模块const express = require(&quot;express&quot;)// 创建express项目const express = express()// 端口号port = 3000app.get(&quot;/&quot;,(req,res)=&gt;&#123; res.send(&quot;Hello World!&quot;)&#125;)// 监听端口，启动express服务器app.listen(port,()=&gt;&#123; console.log(`Example app listening at http://localhost:$&#123;port&#125;`)&#125;)","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"NodeJs","slug":"前端学习栈/NodeJs","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://mgy1021.github.io/tags/NodeJs/"}]},{"title":"nodeJ中的Buffer缓冲器","slug":"nodeJ中的Buffer缓冲器","date":"2021-09-07T01:32:01.000Z","updated":"2021-09-07T14:34:25.379Z","comments":true,"path":"2021/09/07/nodeJ中的Buffer缓冲器/","link":"","permalink":"https://mgy1021.github.io/2021/09/07/nodeJ%E4%B8%AD%E7%9A%84Buffer%E7%BC%93%E5%86%B2%E5%99%A8/","excerpt":"","text":"Buffer缓冲器Buffer类被引入作为Node.js API的一部分，使其可以在TCP流或文件系统操作等场景中处理二进制数据流。可以将Buffer理解为输送二进制数据流的缓存。 Buffer类在全局作用域中，无需导入","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"NodeJs","slug":"前端学习栈/NodeJs","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://mgy1021.github.io/tags/NodeJs/"}]},{"title":"nodeJ中的s文件系统","slug":"nodeJ中的s文件系统","date":"2021-09-07T01:31:39.000Z","updated":"2021-09-07T14:34:18.799Z","comments":true,"path":"2021/09/07/nodeJ中的s文件系统/","link":"","permalink":"https://mgy1021.github.io/2021/09/07/nodeJ%E4%B8%AD%E7%9A%84s%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"使用Node.js读取文件在Nodejs中读取文件最简单的方法是使用fs.readFile()方法，参数：文件路径，字符编码，回调函数。 12345678// 读取文件fs.readFile(&#x27;./1-url.js&#x27;, &#x27;utf8&#x27;, (err, data) =&gt; &#123; if (err) &#123; console.log(err); return &#125; console.log(data);&#125;) 同步版本fs.readFileSync() 使用Node.js写入文件写入文件最简单的方法是使用fs.writeFile()方法,参数：(写入文件，写入内容，回调函数) 12345678// 写入文件fs.writeFile(&quot;./hello.txt&quot;, &quot;hello123&quot;, err =&gt; &#123; if (err) &#123; console.log(err); return &#125; console.log(&quot;写入成功!&quot;);&#125;) 同步版本fs.writeFileSync() 同步读写文件1234567// 同步读写操作try &#123; let data = fs.readFileSync(&quot;./1-url.js&quot;, &quot;utf8&quot;); fs.writeFileSync(&quot;./1-url2.js&quot;, data)&#125; catch (error) &#123; console.log(error);&#125;","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"NodeJs","slug":"前端学习栈/NodeJs","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://mgy1021.github.io/tags/NodeJs/"}]},{"title":"nodeJs中的进程","slug":"nodeJs中的进程","date":"2021-09-07T01:31:22.000Z","updated":"2021-09-07T14:37:03.072Z","comments":true,"path":"2021/09/07/nodeJs中的进程/","link":"","permalink":"https://mgy1021.github.io/2021/09/07/nodeJs%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B/","excerpt":"","text":"process(进程)process对象是一个全局变量，提供了有关当前Node.js进程的信息并对其进行控制。作为全局变量，它始终可供Node.js应用程序使用，无需使用require()导入。 12345678910process.env.NODE_ENV = &quot;development&quot;process.env.BaseURL = &quot;127.0.0.1:8888&quot;console.log(process.env.NODE_ENV);// console.log(process);// 环境对象console.log(process.env);// 参数数组console.log(process.argv);// 关闭进程的方法// process.exit(1); 处理命令行参数： 123const minimist = require(&quot;minimist&quot;);// 处理命令行的参数console.log(minimist(process.argv.slice(2)));","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"NodeJs","slug":"前端学习栈/NodeJs","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://mgy1021.github.io/tags/NodeJs/"},{"name":"进程","slug":"进程","permalink":"https://mgy1021.github.io/tags/%E8%BF%9B%E7%A8%8B/"}]},{"title":"nodeJs搭建简单Http服务器","slug":"nodeJs搭建简单Http服务器","date":"2021-09-07T01:30:54.000Z","updated":"2021-09-07T14:36:20.602Z","comments":true,"path":"2021/09/07/nodeJs搭建简单Http服务器/","link":"","permalink":"https://mgy1021.github.io/2021/09/07/nodeJs%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95Http%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"Http服务器这是一个简单的HTTP web服务器 1.创建服务器对象​ 浏览器每发一次请求，都会运行该函数。 req是请求对象，通过它可以拿到请求的方式、路径、参数,res是响应对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 创建服务器对象let server = http.createServer((req, res) =&gt; &#123; // 设置响应头部的字符编码 res.setHeader(&quot;Content-Type&quot;, &quot;text/plain;charset=utf-8&quot;) // 浏览器每发一次请求，都会运行该函数 // 获取请求方式，获取请求路径，获取请求参数 console.log(req.method); console.log(req.url); // 获取请求路径 let pathname = url.parse(req.url).pathname // 获取get请求参数 // let query = url.parse(req.url).query // 获取post请求的参数 // let params = &quot;&quot;; // 请求发送请求体里的数据的时候触发data事件处理程序 // req.on(&quot;data&quot;, (chunk) =&gt; &#123; // // chunk是Buffer对象,存放一段一段的数据 // params += chunk // &#125;) // end事件监听请求数据发送完毕 // req.on(&quot;end&quot;, () =&gt; &#123; // console.log(params); // &#125;) // console.log(pathname); // console.log(query); // 不同接口路径返回不同数据 if (pathname === &quot;/user/findAll&quot;) &#123; res.end(&#x27;user的findAll&#x27;); &#125; else if (pathname === &quot;/user/deleteById&quot;) &#123; res.end(&#x27;user的deleteById&#x27;); &#125; // 编写响应体的内容 // res.write(&quot;123&quot;); // 结束响应 // res.end();&#125;) 2.启动服务器1234// 启动服务器server.listen(3000, () =&gt; &#123; console.log(&quot;3000端口启动&quot;);&#125;)","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"NodeJs","slug":"前端学习栈/NodeJs","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://mgy1021.github.io/tags/NodeJs/"},{"name":"Http服务器","slug":"Http服务器","permalink":"https://mgy1021.github.io/tags/Http%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"git","slug":"git","date":"2021-08-30T16:34:30.000Z","updated":"2021-09-06T16:15:09.914Z","comments":true,"path":"2021/08/31/git/","link":"","permalink":"https://mgy1021.github.io/2021/08/31/git/","excerpt":"","text":"初始化本地仓库 git init 更新代码 git pull origin master 提交代码 git add . 将需要提交的所有文件添加到缓存区 git commit -m &#39;提交注释&#39; 将缓存区的内容提交到本地仓库里 git remote add origin 仓库地址 将本地仓库与远程仓库绑定 git push origin master 将本地仓库需要提交的文件推送到远程仓库 解绑仓库 git remote remove 仓库名称 查看与本地仓库绑定的远程仓库 git remote -v","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"git","slug":"前端学习栈/git","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://mgy1021.github.io/tags/Git/"}]},{"title":"ES6","slug":"ES6","date":"2021-08-30T16:33:11.000Z","updated":"2021-09-12T03:03:25.227Z","comments":true,"path":"2021/08/31/ES6/","link":"","permalink":"https://mgy1021.github.io/2021/08/31/ES6/","excerpt":"","text":"1. 为什么要学习ES6 ES的本版变动内容最多，具有里程碑意义 ES6加入许多新的语法特性，编程实现更简单、高效 ES6是前端发展趋势，就业必备技能（在三大框架中大量使用了ES6的语法） 2. ES6的新语法1. let声明变量 变量不能重复声明 块级作用域(变量只在代码块里面有效) 不存在变量提升 不影响作用域链 2. const声明常量 常量的值不能修改 声明时必须赋值 块级作用域 对于数组或者对象进行修改，不会报错 3. 解构赋值 ES6允许按照一定模型从数组或者对象中提取值，对变量进行赋值，这被称为解构赋值。 数组解构 1234567const F4 = [&quot;小沈阳&quot;,&quot;刘能&quot;,&quot;赵四&quot;,&quot;宋小宝&quot;]let [xiao,liu,zhao,song] = F4console.log(xiao); // 小沈阳console.log(liu); // 刘能console.log(xiao); // 赵四console.log(song); // 宋小宝 对象解构 12345678910111213const zhao = &#123; name:&#x27;赵本山&#x27;, age:&quot;不详&quot;, xiaopin:function()&#123; console.log(&quot;我可以演小品&quot;); &#125;&#125;let &#123;name,age,xiaopin&#125; = zhao;console.log(name); //赵本山console.log(age); //不详console.log(xiaopin); //xiaopin方法 4. 模板字符串 ES6引入新的声明字符串的方式 1let str = `我是一个模板字符串哦` 特性： 内容中可以直接出现换行符 变量拼接 let lovest = &#39;魏翔&#39; 1let out = `$&#123;lovest&#125;是我心目中最搞笑的演员` 5. 简化对象 ES6允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。 123456789101112let name = &quot;Mogy&quot;;let change = function()&#123; console.log(&quot;我们可以改变你&quot;)&#125;const school = &#123; name, change, improve()&#123; console.log(&quot;我们可以提升你的技能&quot;) &#125;&#125; 6.箭头函数 特性 this是静态的，this始终是指向函数声明时所在作用域下的this的值。 不能作为构造实例化对象 不能使用arguments变量 箭头函数的简写 省略小括号，当形参有且只有一个时可省略 省略大括号，当代码体中的语句只有一句时可以省略 let pow = n =&gt; n*n 使用场景 箭头函数适合与this无关的回调，定时器，数组的方法回调 箭头函数不适合与this有关的回调，事件回调，对象的方法 7. ES6允许给函数参数赋值初始值 形参初始值（具有默认值的参数，一般位置要靠后） 12345function add(a,b,c=10)&#123; return a+b+c&#125;let result = add(1,2,3) // 6let result = add(1,2) // 13 与解构赋值结合使用 12345678910111213141516171819202122function connect(&#123;host = 127.0.0.1,username,password,port&#125;)&#123; console.log(host); console.log(username); console.log(password); console.log(port);&#125;//传host参数时输出connect(&#123; host:&#x27;baidu.com&#x27;, //输出baidu.com username:&#x27;root&#x27;, //输出root password:&#x27;root&#x27;, //输出root port:3306 //输出3306&#125;)//不host参数时输出默认值connect(&#123; //host输出默认值127.0.0.1 username:&#x27;root&#x27;, //输出root password:&#x27;root&#x27;, //输出root port:3306 //输出3306&#125;) 8. rest参数 ES6引入reset参数，用于获取函数的实参，用来代替arguments 12345function date(...args)&#123; console.log(args);&#125;date(&#x27;阿娇&#x27;,&#x27;柏芝&#x27;,&#x27;思慧&#x27;); //数组 可以使用filter some every map等数组方法 reset参数必须要放到参数最后 9. 扩展运算符... 扩展运算符能将数组转换为逗号分隔的参数列表。 1234567const tfboys = [&quot;易烊千玺&quot;,&quot;王源&quot;,&quot;王俊凯&quot;];//声明一个函数function chunwan()&#123; console.log(arguments)&#125;chunwan(...tfboys) // 相当于chunwan(&quot;易烊千玺&quot;,&quot;王源&quot;,&quot;王俊凯&quot;)// 数组的克隆const sanzhihua = [&#x27;E&#x27;,&#x27;G&#x27;,&#x27;M&#x27;];const sanyecao = [...sanzhihua] // [&#x27;E&#x27;,&#x27;G&#x27;,&#x27;M&#x27;] 10. Symbol基本使用 ES6引入了一种新的数据类型Symbol，表示独一无二的值。它是JS语言的第七种数据类型，是一种类似于字符串的数据类型。 Symbol的特点 Symbol的值是唯一的，用来解决命名冲突的问题 Symbol的值不能与其他数据进行运算 Symbol定义的对象属性不能使用for...in循环遍历，但是可以使用Reflect.ownKeys来获取对象的所有键名 1//创建一个Symbollet s = Symbol();console.log(s,typeof s); // Symbol() &quot;Symbol&quot;let s2 = Symbol(&quot;注释&quot;);let s3 = Symbol(&quot;注释&quot;);console.log(s2 == s3) // false// Symbol.for 创建let s4 = Symbol.for(&#x27;Mogy&#x27;);let s5 = Symbol.for(&#x27;Mogy&#x27;);console.log(s4 == s5) // true Symbol的使用场景 给对象添加属性或者方法，表示独一无二的 1234567891011121314151617181920let game = &#123; name: &#x27;俄罗斯方块&#x27;, up() &#123; console.log(&quot;向上&quot;); &#125;, down() &#123; console.log(&quot;向下&quot;); &#125;&#125;let methods = &#123; up: Symbol(), down: Symbol(),&#125;game[methods.up] = function () &#123; console.log(&quot;我可以改变形状&quot;);&#125;game[methods.down] = function () &#123; console.log(&quot;我可以快速下降&quot;);&#125;console.log(game); 11. 迭代器​ 迭代器是一种接口，为各种不同的数据类型提供统一的访问机制。任何数据结构只要部署了Iterator接口(指的是对象里的一个属性)，就可以完成遍历操作。 原生具备Iterator接口的数据 Array Arguments Set Map String TypedArray NodeList 工作原理 创建一个指针对象，指向当前数据结构的起始位置 第一次调用对象的next方法，指针自动指向数据结构的第一个成员 接下来不断调用next方法，指针一直往后移动，直到指向最后一个成员 12. 生成器​ 生成器其实就是一个特殊的函数 123456789101112function* gen() &#123; console.log(111); yield 1 console.log(222); yield 2 console.log(333); yield 3&#125;let Iterator = gen() // 返回一个迭代器对象Iterator.next() // 111Iterator.next() // 222Iterator.next() // 333 13. Set集合​ ES6提供了新的数据结构Set集合，它是一个对象，类似于数组，但是成员是唯一的。 1234567891011121314//声明一个 setlet s = new Set();let s2 = new Set([&quot;好事&quot;, &quot;喜事&quot;, &quot;坏事&quot;, &quot;丑事&quot;, &quot;好事&quot;]);console.log(typeof s) // Object// 获取元素的个数console.log(s2.size) // 4// 添加元素s2.add(&quot;悲事&quot;)// 删除元素s2.delete(&quot;好事&quot;)// 检测s2.has(&quot;好事&quot;)// 清空s2.clear() 14.类15.数值扩展 Number.EPSILON Number.EPSILON是JavaScript表示的最小精度 123456789console.log(0.1 + 0.2 === 0.3) // falsefunction equal(a, b) &#123; if (Math.abs(a - b) &lt; Number.EPSILON) &#123; return true; &#125; else &#123; return false; &#125;&#125;console.log(equal(0.1 + 0.2, 0.3)) // true Number.isFinite 检查一个数值是否为有限数 Number.isNaN 检测一个数值是否为NaN Number.parseInt 字符串转整数 Number.isInteger 判断一个数是否为整数 Math.trunc 将数字的小数部分抹掉 Math.sign 判断一个数是整数、负数还是零 16.对象方法的扩展 Object.is 判断两个值是否完全相等 Object.assign 对象合并 Object.setPrototypeOf Object.getPrototypeOf 设置原型对象 17.模块化​ 模块化是指将一个大的程序文件，拆分成许多小的文件，然后将小文件组合起来。 模块化开发的好处 防止命名冲突 代码复用 高维护性 模块化规范 CommonJS =&gt; NodeJS、Browserify AMD =&gt; requireJS CMD =&gt; seaJS ES6模块化语法 export命令用于规定模块的对外接口 import命令用于输入其他模块提供的功能 导出的方式： export let a = 2 export &#123;a,method&#125; export default &#123;对象&#125; 引入的方式： 通用方式 import * as m1 from &quot;...&quot; 解构赋值形式 import &#123;school,teach&#125; from &quot;...&quot; import &#123;default as m3&#125; from &quot;...&quot; 简便形式(针对默认暴露) import m3 from &quot;...&quot; babel 1npx babel 文件 -d 文件夹 --presets=babel-preset-env 模块化的差异 ES6模块与CommonJS模块化的差异： CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用 ES6模块加载的不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。 ES6模块输出的是值的引用 CommonJS模块是运行时加载，ES6模块时编译时输出接口 加载的是一个对象,即module.exports属性，该对象只有在脚本运行完才能完成。 3. ES7的新特性 Array.prototype.includes 用来检测数组中是否包含某个元素，返回布尔类型值 **幂运算 相当于Math.pow(), 2**3 ==&gt; Math.pow(2,3) 4.ES8的新特性4.1 async和await​ 异步编程的解决方案，async和await两种语法结合可以让异步代码像同步代码一样编写 4.1.1 async函数 async函数的返回值为promise对象 promise对象的结果由async函数执行的返回值决定 4.1.2 await表达式 await必须写在async函数中 await右侧的表达式一般为promise对象 await返回的是promise成功的值 await的promise失败了，就会抛出异常，需要通过try…catch捕获处理","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"ES6","slug":"前端学习栈/ES6","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://mgy1021.github.io/tags/ES6/"}],"author":"Mogy"},{"title":"Ajax","slug":"Ajax","date":"2021-08-30T16:30:29.000Z","updated":"2021-09-07T13:12:58.498Z","comments":true,"path":"2021/08/31/Ajax/","link":"","permalink":"https://mgy1021.github.io/2021/08/31/Ajax/","excerpt":"","text":"AJAX的特点1.AJAX的优点 （1）可以无需刷新页面与服务器进行通信 （2）允许你根据用户事件来更新部分网页内容 2.AJAX的缺点 （1）没有浏览历史，不能回退 （2）存在跨域问题（同源） （3）SEO不友好 AJAX的使用1.AJAX的基本操作 12345678910111213141516&lt;!-- 1.创建对象 --&gt;const xhr = new XMLHttpRequest()&lt;!-- 2.初始化 设置请求方式和URL --&gt;xhr.open(&#x27;GET&#x27;，URL)&lt;!-- 3.发送 --&gt;xhr.send()&lt;!-- 4.绑定事件 --&gt;xhr.onreadyStateChange = function () &#123; &lt;!-- 判断（服务器是否返回全部结果） --&gt; if(xhr.readyState === 4)&#123; &lt;!-- 判断（响应是否成功） --&gt; if(xhr.status &gt;= 200&amp;&amp;xhr.status &lt; 300)&#123; console.log(xhr.response) &#125; &#125;&#125; 2.传参 （1）GET请求 在URL后面拼接，例如:http://127.0.0.1:8000/server?username=Mogy&amp;age=12 （2）POST请求 在send方法中传参，例如：xhr.send(‘username=Mogy&amp;age=12’) 3.超时请求和网络异常处理 （1）超时请求 xhr.timeout = 2000 （2）网络异常处理 123xhr.onerror = function () &#123; alert(&quot;你的网络似乎出了问题!!!&quot;) &#125; 4.手动取消请求 （1）xhr.abort() Jquery发送ajax1.发GET $.get(url,data,function()&#123;&#125;,&#39;json&#39;) 2.发POST $.post(url,data,function()&#123;&#125;) 3.通用方法 12345678910111213141516$.ajax(&#123; &lt;!-- 请求路径 --&gt; url:&#x27;&#x27;, &lt;!-- 请求方式 --&gt; type:&#x27;&#x27;, &lt;!-- 参数 --&gt; data:&#123;&#125;, &lt;!-- 设置响应体的数据类型 --&gt; datatype:&#x27;json&#x27; &lt;!-- 成功回调 --&gt; success()&#123;&#125;, &lt;!-- 错误回调 --&gt; error()&#123;&#125;, &lt;!-- 设置请求超时 --&gt; timeout:2000,&#125;) axios发ajax1.发GET请求 axios.get(url,config).then().catch() 2.发POST请求 axios.post(url,data,config),then().catch() 3.通用方法 123456789101112axios(&#123; &lt;!-- 请求路径 --&gt; url:&#x27;&#x27;, &lt;!-- 请求方式 --&gt; method:&#x27;&#x27;, &lt;!-- 设置请求头 --&gt; headers:&#123;&#125;, &lt;!-- 请求体 --&gt; data:&#123;&#125; &lt;!-- url传参 --&gt; params:&#123;&#125;&#125;) ajax同源策略 1.同源策略是浏览器的一种安全策略 2.同源：协议、域名、端口号 必须完全相同 3.违背同源策略就是跨域 解决跨域： Jsonp Cros 浏览器解决跨域： https://blog.csdn.net/qq_37338983/article/details/78606064 火狐浏览器下载CORS-EVERYWHERE插件即可解决跨域问题 HTTP协议1.HTTP简介 超文本传输协议，协议详细规定了浏览器和万维网服务器之间相互通信的规则 2.内容 1.请求报文 重点是格式和参数： 1234行 POST /s?ie=utf-8 HTTP/1.1头 空行体 2.响应报文 1234行 HTTP/1.1 200 OK头空行体","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"Ajax","slug":"前端学习栈/Ajax","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/Ajax/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://mgy1021.github.io/tags/Ajax/"}]},{"title":"Webpack","slug":"Webpack","date":"2021-08-20T01:31:05.000Z","updated":"2021-09-08T01:11:06.916Z","comments":true,"path":"2021/08/20/Webpack/","link":"","permalink":"https://mgy1021.github.io/2021/08/20/Webpack/","excerpt":"","text":"Webpack的简介1. 什么是Webpack？Webpac是一种前端资源构建工具，一个静态模块打包器(module bundler)。 在Webpack看来，前端的所有资源文件(js/json/css/img/less/…)都会作为模块处理。它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源(bundle)。 2. Webpack的五个核心概念2.1 Entry​ 入口(entry)指示Webpack以哪个文件为入口起点开始打包，分析构建内部依赖图。 2.2 Output​ 输出(output)指示Webpack打包后的资源bundle输出到哪里去，以及如何命名。 2.3 loader​ Loader让webpack能够处理一些非JavaScript文件(webpack自身只认识JavaScript) 2.4 Plugins​ 插件(Plugins)可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩一直到重新定义环境中的变量等。 2.5 Mode​ 模式(Mode)指示Webpack使用相应模式的配置。 选项 描述 特点 development 会将process.env.NODE_ENV的值设为development。启用NamedChunksPlugin和NamedModulesPlugin. 能够让本地调试运行环境 production 会将process.env.NODE_ENV的值设为production。启用FlagDependencyUsagePlugin等 能够让代码优化上线运行的环境 3. Webpack初体验3.1 运行指令​ 开发环境：webpack ./src/index.js -o ./build/build.js –mode=development ​ webpack会以 ./src/index.js为入口文件开始打包，打包后输出到./build/built.js文件 ​ 整体打包环境是开发环境 ​ 生产环境：webpack ./src/index.js -o ./build/build.js –mode=production ​ webpack会以 ./src/index.js为入口文件开始打包，打包后输出到./build/built.js文件 ​ 整体打包环境是生产环境 3.2 结论 webpack能处理js/json资源,不能处理css/img等其他资源。 生产环境和开发环境将ES6模块化编译成浏览器能识别的模块化。 生产环境比开发环境多一个压缩代码。 4. 打包样式资源webpack.config.js是webpack的配置文件 作用：指示webpack干哪些活（当你运行webpack指令时，会加载里面的配置） 注意：所有构建工具都是基于nodejs平台运行的~模块化默认采用commonJS 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* * @Description: * @Author: Mogy * @Date: 2021-08-19 14:51:29 * @LastEditors: Mogy * @LastEditTime: 2021-08-19 15:34:37 *///resolve用来拼接绝对路径的方法const &#123; resolve &#125; = require(&quot;path&quot;)module.exports = &#123; // webpack配置 entry: &#x27;./src/index.js&#x27;, // 输出 output: &#123; // 输出文件名 filename: &#x27;built.js&#x27;, // 输出的路径 //__dirname nodejs的变量，代表当前文件所在目录的绝对路径 path: resolve(__dirname, &#x27;build&#x27;) &#125;, //loader的配置 module: &#123; rules: [ //详细的loader配置 // 不同文件必须配置不同的loader处理 &#123; //匹配哪些文件 test: /\\.css$/, // 使用哪些loader进行处理 use: [ //use数组中loader执行顺序：从右到左，从上到下。依次执行 //创建style标签，将js中的css样式资源插入进去，添加到head中生效 &#x27;style-loader&#x27;, //将css文件编成commonJS模块加载到js中，里面的内容是样式字符串 &#x27;css-loader&#x27; ] &#125;, &#123; test: /\\.less$/, use: [ &quot;style-loader&quot;, &quot;css-loader&quot;, // 将less文件编译成css文件 &quot;less-loader&quot; ] &#125; ] &#125;, // plugins的配置 plugins: [ //详细plugins的配置 ], // 模式 mode: &#x27;development&#x27;, // mode: &#x27;production&#x27;&#125; 5. Webpack打包html资源123456789101112131415161718192021222324252627282930313233343536373839404142434445/* * @Description: * @Author: Mogy * @Date: 2021-08-19 15:45:13 * @LastEditors: Mogy * @LastEditTime: 2021-08-19 16:00:22 *//* loader: 1. 下载 2. 使用（配置loader） plugins： 1. 下载 2. 引入 3. 使用*/const &#123; resolve &#125; = require(&#x27;path&#x27;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;built.js&#x27;, path: resolve(__dirname, &quot;build&quot;) &#125;, module: &#123; rules: [ // loader的配置 ] &#125;, plugins: [ // plugins的配置 // html-webpack-plugin // 功能：默认会创建一个空的HTML文件，自动引入打包输出的所有资源(JS/CSS) // 需求：需要有结构的HTML文件 new HtmlWebpackPlugin(&#123; // 复制一个HTML文件，并自动引入打包输出的所有资源(JS/CSS) template: &#x27;./src/index.html&#x27; &#125;) ], mode: &quot;development&quot;&#125; 6. Webpack打包图片资源","categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"Webpack","slug":"前端学习栈/Webpack","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://mgy1021.github.io/tags/Webpack/"}]}],"categories":[{"name":"前端学习栈","slug":"前端学习栈","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"name":"NodeJs","slug":"前端学习栈/NodeJs","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/NodeJs/"},{"name":"git","slug":"前端学习栈/git","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/git/"},{"name":"ES6","slug":"前端学习栈/ES6","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/ES6/"},{"name":"Ajax","slug":"前端学习栈/Ajax","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/Ajax/"},{"name":"Webpack","slug":"前端学习栈/Webpack","permalink":"https://mgy1021.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%A0%88/Webpack/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://mgy1021.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://mgy1021.github.io/tags/JavaScript/"},{"name":"事件轮询","slug":"事件轮询","permalink":"https://mgy1021.github.io/tags/%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2/"},{"name":"NodeJs","slug":"NodeJs","permalink":"https://mgy1021.github.io/tags/NodeJs/"},{"name":"nodemon","slug":"nodemon","permalink":"https://mgy1021.github.io/tags/nodemon/"},{"name":"Mysql","slug":"Mysql","permalink":"https://mgy1021.github.io/tags/Mysql/"},{"name":"进程","slug":"进程","permalink":"https://mgy1021.github.io/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"Http服务器","slug":"Http服务器","permalink":"https://mgy1021.github.io/tags/Http%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Git","slug":"Git","permalink":"https://mgy1021.github.io/tags/Git/"},{"name":"ES6","slug":"ES6","permalink":"https://mgy1021.github.io/tags/ES6/"},{"name":"Ajax","slug":"Ajax","permalink":"https://mgy1021.github.io/tags/Ajax/"},{"name":"Webpack","slug":"Webpack","permalink":"https://mgy1021.github.io/tags/Webpack/"}]}